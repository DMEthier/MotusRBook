# Accessing and understanding detections data {#accessingData}

```{r tidyr3, echo = FALSE, message = FALSE, warning = FALSE}

library(knitr)
opts_chunk$set(tidy.opts=list(width.cutoff=50), tidy = TRUE)

```

**Before downloading your detection data, please ensure that you have no pending metadata issues through the online [Data Issues page](https://motus.org/data/issues)**

## Database types {#databaseTypes}

There are two types of tag databases:

1. **receiver database**: includes all detections of any registered tags from a single receiver. A receiver database has a name like SG-1234BBBK5678.motus, where the name is the serial number of the receiver.

2. **project database**: includes all detections of your registered tags from across the Motus network. A tag project database has a name like project-123.motus, where the number is the Motus project ID.

These two databases correspond to the basic model of data sharing:

1. you get all detections of anyone's tags by *your* receivers (i.e., one receiver tag database for each receiver you deploy).

2. you get all detections of *your* tags by *anyone's* receivers (i.e., one project tag database for each of your Motus projects).

## Load relevant R packages {#loadPackages}

Before we begin working with data, we need to load the required packages for this chapter. If you have not yet installed these packages (from github and CRAN) then please return to Chapter \@ref(loadingPackages) and do so.

```{r loadPackages, warning = FALSE, message = FALSE}

# required 'motus' package from github
require(motus)

```

## Set system environment

Set the system environment time zone to Greenwich Mean Time (GMT), to ensure that you are always working in GMT. This is a very important step, and should be part of every working session. If you fail to do this, then two problems can arise. Times are stored in the Motus database in GMT, and if you do not keep your environment in GMT, then they can be inadvertently changed during import. Second, if tags have been detected across multiple time zones, then they can also inadvertently be changed.

```{r setTimeZone1}

Sys.setenv(TZ="GMT")

```

## Importing tag detections {#importDetections}

To import tag detections for your project or receiver, you need a numerical project id or character scalar receiver serial number. 

The success of the Motus network is dependent on the timely upload of detection data from receivers, and on the maintenance of accurate and up to date tag and receiver metadata by collaborators. After downloading your data from the Motus server, users are encouraged to check for updated detection data and metadata each time they run an analysis, because collaborators can add detection data and metadata at any time, and these could influence the completeness of your own detections data.

### Download data for a project or receiver for the _first time_

When downloading data from the Motus server for the first time, you must specify 'new = TRUE' and 'update = TRUE'. Unless the directory that you want your data saved in is stated explicitly within the function call, data will be downloaded to the current working directory. 

### User Authentication {#userAuthentication}

Note that the first time you call a function using the Motus R package, you will be asked to enter your motus.org username and password in the R console to authenticate your access to project data. This will only happen once per R session. If you do not have a Motus username and password, you can sign up at <https://motus.org/data/user/new>. Permission to access project data will then be granted by Motus staff or the project principal investigator.

Throughout this book we will use sample data (see section \@ref(sampleData)) which has been assigned to project 176.  When accessing this data you will need to login as follows:

```{r password, eval = FALSE}

user name: motus.sample
password: motus.sample

```

### Logging out {#logout}

Once you are logged in under one user account, you will not be able to access data from another account.  If you need to logout of the current account to access other data, you can run the code below.

```{r logout, eval = FALSE}

motusLogout()

```

### Downloading detection data {#downloadData}

Let's get started. Note that there are no receivers registered to sample project 176, so the second call (by receiver) will not find any data. You can, however, replace the receiver serial number with one registered to your project if you are logged in under your own credentials (ie. not motus.sample account, see section \@ref(logout)). 

Be warned that large datasets can take some time (sometimes a few hours) to download from the Motus server when downloading for the first time ('new = TRUE' in the tagme function call). After the initial download, loading a .motus file into R using 'tagme(proj.num, update = TRUE)' will be near instantaneous. The download process should print its progress on the console; if you are not seeing it, try scrolling down your screen while tagme is running.

In the event that your connection to the Motus server fails prior to the download completing (e.g., due to poor internet connection), use 'tagme(proj.num, update = TRUE)' to continue the download from where it left off, ensuring to specify a directory if it is saved outside the working directory.  


```{r tagme1, eval = FALSE}

getwd()         # show working directory; use setwd() to change it.
proj.num <- 176 # 176 for the sample data, or insert your project number

sql.motus <- tagme(projRecv = proj.num, new = TRUE, update = TRUE)  # for project tag database
sql.motus <- tagme(projRecv = "SG-123BBBK1234", update = TRUE, new = TRUE)  # for receiver tag database

```

If you don't want to use the working directory, specify a directory to create and open a local tag database using 'dir = ':

```{r tagme2, eval = FALSE}

sql.motus <- tagme(projRecv = proj.num, new = TRUE, update = TRUE, dir = "./data/") 

```

```{r sql.motus, echo = FALSE}
# hidden function to load sql.motus file into working directory for rest of book to work
sql.motus <- tagme(176, update = FALSE, dir = "./data")
```

The tagme() function will write a copy of your tag database to the working or specified folder, stored as an SQLite file with the extension '.motus'. 

### Update and open a local tag database {#tagmeUpdate}

To open and update a detections database that already exists (has been downloaded previously):

```{r tagme3, eval = FALSE}

sql.motus <- tagme(projRecv = proj.num, new = FALSE, update = TRUE, dir = "./data/") # use dir = to specify a directory

```

If you are working offline, and want to load an already downloaded database without connecting to the server, use:

```{r tagme3.1, eval = FALSE}

sql.motus <- tagme(projRecv = proj.num, update = FALSE, dir = "./data/")

```

### Check if new data are available {#tellme}

To check if new data are available without downloading the data, you can use the tellme() function, which returns a list with:

- **numHits**: number of new tag detections.
- **numBytes**: approximate uncompressed size of data transfer required, in megabytes.
- **numRuns**: number of runs of new tag detections, where a run is a series of continuous detections for a tag on a given antenna.
- **numBatches**: number of batches of new data. 
- **numGPS**: number of GPS records of new data.

The following assumes that a local copy of the database already exists:

```{r tagme5, eval = FALSE}

tellme(projRecv = proj.num)                    # If db is in the working directory
tellme(projRecv = proj.num, dir = "./data/")   # To specify a different directory

```

To check how much data is available for a project but you _do not_ have a database for it, use the 'new' parameter:

```{r tagme6, eval = FALSE}

tellme(projRecv = proj.num, new = TRUE)

```

### Force an update/re-import of tag and receiver deployment metadata {#forceMeta}

Tag and receiver metadata are automatically merged with tag detections when data are downloaded. However, if you want to force a re-import of the metadata when updating a database, you can run:  

```{r tagme7, eval = FALSE}

sql.motus <- tagme(projRecv = proj.num, forceMeta = TRUE)

```

### Import full tag and receiver metadata {#metadata}

When you use tagme() to download or update your .motus file, you are provided with the metadata for:

1. any tags registered to your project which have detections; 
2. tags from other projects which are associated with ambiguous detections (see Chapter \@ref(dataCleaning)) in your data; 
3. receivers that your tags, plus ambiguous tags, were detected on.  

In many instances, you will want access to the full metadata for all tags and receivers across the network, e.g., to determine how many of your deployed tags were not detected, or to plot the location of stations with and without detections. The metadata() function can be used to add the complete Motus metadata to your saved .motus file. The metadata function only needs to be run once, but we suggest that you re-import the metadata occasionally to ensure that you have the most recent and up-to-date information.

Running the metadata function as follows will add the appropriate metadata from across the network (all tags and all receivers) to the 'recvDeps' and 'tagDeps' tables in your .motus file: 

```{r metadata1, eval = FALSE}

# access all tag and receiver metadata for all projects in the network.
metadata(sql.motus) 

```

Alternatively, you can load metadata for a specific project(s) using:

```{r metadata2, eval = FALSE}

# access tag and receiver metadata associated with project 176
metadata(sql.motus, projectIDs = 176) 

# access tag and receiver metadata associated with projects 176 and 1
metadata(sql.motus, projectIDs = c(176, 1)) 

```


## Data structure {#databaseStructure}

Each tag database is stored as an SQLite ('dplyr::src_sqlite') file with the extension '.motus'. The sqlite format was chosen because:

1. it is flexible, allowing for many data formats.
2. it is accessible from many software platforms (not just R).
3. it is **appendable**: the database can be created and updated on disk without having to read in and resave the entire contents. This will save time and computer memory when searching to see if any new detections are available for your project or receiver.

The .motus file contains a series of interrelated tables where data are stored in a condensed format to save memory. The following tables are included in the .motus file;

1. antDeps: metadata related to antenna deployments, e.g., deployment height, angle, antenna type.
2. batchRuns: metadata for runIDs and associated batchIDs
3. batches: detection data for a given receiver and boot number.
4. filters: metadata related to user created filters associated with the specified receiver.  
5. gps: metadata related to Geographic Positioning System (GPS) position of receiver. 
6. hits: detection data at the level of individual hits.
7. meta: metadata related to the project and datatype (tags vs. receivers) that are included in the .motus file
8. projAmbig: metadata related to what projects have ambiguous tag detections
9. projBatch: metadata for the number of detections contained in each batch
10. projs: metadata related to projects, e.g., project name, principal investigator.
11. recvDeps: metadata related to receiver deployments, e.g., deployment date, location, receiver characteristics.
12. recvs: metadata related to receiver serial number and associated Motus deviceID
13. runs: detection data associated with a run (continuous detections of a unique tag on a given receiver).
14. runsFilters: a list of runIDs associated with user created filters and assigned probabilities.  
15. species: metadata related to species, e.g., unique identifier, scientific name, common name.
16. tagAmbig: metadata related to ambiguous tags, e.g., ambigID and associated motusTagID
17. tagDeps: metadata related to tag deployments, e.g., deployment date, location, and species.
18. tags: metadata related to tags, e.g., unique identifier, tag characteristics (e.g., burst interval).

You can view the list of tables, and variables contained within those tables using the code below:

```{r sqlTables, eval = FALSE}

# specify the location and project file name.
file.name <- dbConnect(SQLite(), "./data/project-176.motus") 

# get a list of tables in the .motus file specified above.
dbListTables(file.name) 

# get a list of variables in the "species" table in the .motus file.
dbListFields(file.name, "species") 

```

In addition to these tables, there are also 'virtual' tables or 'views', which have been created through queries that merge data from the various tables into a single convenient 'view' that contains all of the fields you are likely to need. The following views are currently included in each .motus file:

1. allambigs: lists in long-data format each motusTagID (up to 6) associated with each negative ambigID.
2. alltags: provides the full detection data for all tags, and all ambiguous (duplicate) tags,  associated with your project. Ambiguous detections are repeated for each motusTagID represented by each ambigID. 

Because the file is a dplyr::src_sqlite file, all of the dplyr functions can be used to filter and summarize the .motus database, without needing to first save the data as a *flat* file (a typical two-dimensional dataframe). The SQL format is very advantageous when you have a large file -- the queries using SQL will be substantially faster than those done on a flat dataframe. 

Each table and view in the .motus file can be accessed using the tbl() function. 

```{r getTable}

# get the tag deployment metadata table for the current project
tbl.tagDeps <- tbl(sql.motus, "tagDeps")
     
```

The underlying structure of these tables is a list of length 2:

```{r dfStructure, eval = FALSE}

str(tbl.tagDeps)

```

The first part of the list, 'src', is a list that provides details of the SQLiteConnection, including where the database is stored. The second part is a list that includes the underlying table. Thus, the R object 'tagDeps' is a *virtual* table that stores the database structure and information required to connect to the underlying data in the .motus file. As stated above, the advantage of storing the data in this way is that it saves memory when accessing very large databases, and functions within the dplyr package can be used to manipulate and summarize the tables before collecting the results into a typical "flat" format dataframe.

If you want to use familiar functions to get access to components of the underlying data frame, then use the 'collect' function. For example, to look at the names of the variables in tagDeps:

```{r}

tbl.tagDeps %>% 
  collect() %>%
  names() # list the variable names in the table

```

The *virtual* table 'alltags' contains the detection data, along with all metadata variables that most users will ever need from the various underlying .motus tables. It too is accessed using the dplyr tbl() function:  

```{r getAllTagsTable, eval = FALSE}

tbl.alltags <- tbl(sql.motus, "alltags") # virtual table

```

The following table lists the variables available in the 'alltags' view, a full description of each field is available in Appendix A.

```{r parameterTable.3, echo = FALSE, eval = FALSE}

tbl.alltags %>% 
      collect() %>%
      names()

```

## Ensure that you have the correct database version {checkVersion}

When you call the tagme function to load the sqlite database, there is a process that will verify that your database has the version matching the most current version of the motus package and store the version in a new table called admInfo. Over time, changes will be made that require adding new tables, views or fields to the database. If you do not have the correct version, some of the examples contained in this book may not work. The following call will check that your database has been updated to the version matching the current version of the motus package. If you do not have the most current version, see Chapter \@ref(loadingPackages) for instructions on updating motus and motusClient.  Refer to Appendix B if this call returns a warning.


```{r dbVersion, eval = FALSE}
checkVersion(sql.motus)

```

## Convert a SQLITE table to a flat dataframe {#convertToFlat}

To convert the 'alltags' view or other table in the .motus file into a typical 'flat' format, i.e., with every record for each field filled in, use the 'collect()' and 'as.data.frame()' functions. The output can then be further manipulated, or used to generate a RDS file of your data for archiving or export. 

We suggest the following workflow. Prepare a script that downloads/updates your data, filters out the necessary variables, and that does any initial cleaning, and then save the resulting data as an RDS file. We suggest using RDS instead of CSV, because the RDS format preserves the underlying structure of the data (e.g. POSIX times stay as POSIX times). If you want to export your data to another program, then a CSV format might be preferred.  

We caution that producing a flat file using the full suite of fields can use a lot of memory, and can slow R down considerably when dealing with large datasets. For some combinations of data sets and computers, it may be impossible to directly use data frames in R. If that is the case, then this is the point in your workflow where you should carefully consider the information you need from within your data set (for example, how it is aggregated) and simplify it. You can always return to this script, creating a new RDS file with different variables, or aggregated at a different scale.  

We elaborate on this idea in the following sections.  

Make a data frame ...

```{r collect, eval = FALSE}

df.alltags <- tbl.alltags %>% 
                collect() %>% 
                as.data.frame()  # for all fields in the df

```

... and take a quick look at the resulting file. 

```{r quickLook, eval = FALSE}

names(df.alltags)     # field names
str(df.alltags)       # Look at the structure of your data fields
head(df.alltags)      # Look at first 6 rows of your df
summary(df.alltags)   # summary of each column in your df

```

Note that the format of the time stamp (ts) field is numeric and represents seconds since January 1 1970. We recommend that when you transform your tables into flat dataframes, that you format the time stamp using the lubridate package at that time, e.g.:

```{r collect_TimeStamp, eval = FALSE}

df.alltags <- tbl.alltags %>% 
                collect() %>% 
                as.data.frame() %>%     # for all fields in the df (data frame)
                mutate(ts = as_datetime(ts, tz = "UTC", origin = "1970-01-01"))

# the tz = "UTC" is not necessary here, provided you have set your system time to UTC/GMT
# ... but it serves as a useful reminder!

```

If you want to load only part of your entire virtual table (e.g. certain fields, certain tags, or all tags from a specified project or species), you can use dplyr funtions to filter the data before collecting into a dataframe. Some examples are below:  

1. To select certain variables:

```{r collect1, eval = FALSE}

# to grab a subset of variables, in this case a unique list of Motus tag IDs at each receiver and antenna.
df.alltagsSub <- select(tbl.alltags, recv, port, motusTagID) %>%
  distinct() %>% 
  collect() %>% 
  as.data.frame() 

```

2. To select certain tag IDs:

```{r collect2, eval = FALSE}
# filter to include only motusTagIDs 16011, 23316
df.alltagsSub <- filter(tbl.alltags, motusTagID %in% c(16011, 23316)) %>% 
                  collect() %>% 
                  as.data.frame() %>%    
                  mutate(ts = as_datetime(ts, tz = "UTC", origin = "1970-01-01"))    

```

3. To select a specified species:

```{r collect3, eval = FALSE}

# filter to only Red Knot (using speciesID)
df.4670 <- filter(tbl.alltags, speciesID == 4670) %>%  
  collect() %>% 
  as.data.frame() %>%    
  mutate(ts = as_datetime(ts, tz = "UTC", origin = "1970-01-01"))  

# filter to only Red Knot (using English name)
df.redKnot <- filter(tbl.alltags, speciesEN == "Red Knot") %>%   
  collect() %>% 
  as.data.frame() %>%    
  mutate(ts = as_datetime(ts, tz = "UTC", origin = "1970-01-01"))    

```

Using dplyr(), your virtual table can also be summarized before converting to a flat file. For example, to find the number of different detections for each tag at each receiver:

```{r collectSum, eval = FALSE}

df.detectSum <- tbl.alltags %>% 
  group_by(motusTagID, recv) %>%
  tally() %>%
  collect() %>%
  as.data.frame() 

```

In later chapter(s) we will show you additional ways of summarizing and working with your data.

## Export your 'flat' dataframe to CSV or RDS file {#exportDetections}

We re-iterated that a good workflow is to create a script that deals with all of your data issues, then saves a dataframe (or workspace) for re-use. If you do this, you can quickly start an analysis or visualization session from a known (and consistent) starting point. We use an RDS file, which preserves all of the associated R data structures (such as time stamps).

```{r createRDS, eval = FALSE, message = FALSE, warning = FALSE}

# save an RDS file

saveRDS(df.alltags, "./data/df.alltags.RDS")  

# or save as CSV file, which does not preserve time stamps, 
# but can be read more easily by other programs.

write_csv(df.alltags, "./data/df.alltags.CSV")

```

## R object naming convention

Throughout this chapter and the rest of the book, we name R objects according to their structure and the source of the data contained in the object. So, SQLite objects will be prefixed with 'sql.', virtual table objects will be prefixed with 'tbl.', and dataframe objects will be prefixed with 'df.'; the rest of the name will include the name of the .motus table that the data originates from. Throughout the rest of the book we will be relying on and referencing the naming formats below; please ensure that you are familiar with these before continuing to the next chapter. The following code assumes you have already downloaded the sample data and do not need to update it; if you have not, see section \@ref(downloadData) for instructions on initial download:

```{r namingConvention, eval = FALSE}

# SQLite R object, which links to the .motus file:
sql.motus <- tagme(176, update = TRUE, dir = "./data")  

# virtual table object of the alltags table in the sample.motus file:
tbl.alltags <- tbl(sql.motus, "alltags")  
df.alltags <- tbl.alltags %>%
                collect() %>%
                as.data.frame() %>%   # dataframe ("flat") object of alltags table
                mutate(ts = as_datetime(ts, tz = "UTC", origin = "1970-01-01"))              

```

```{r dataImport, echo = FALSE, eval = TRUE}
# hidden data import so update can be set to FALSE
proj.num= 176
sql.motus <- tagme(176, update = FALSE, dir = "./data")   # SQLite R object, which links to the .motus file
tbl.alltags <- tbl(sql.motus, "alltags")  # virtual table object of the alltags table in the
                                          # sample.motus file
df.alltags <- tbl.alltags %>%
                collect() %>%
                as.data.frame() %>%        # dataframe ("flat") object of the alltags table
                mutate(ts = as_datetime(ts, tz = "UTC", origin = "1970-01-01"))              

```

In the next chapter we will check for missing metadata.