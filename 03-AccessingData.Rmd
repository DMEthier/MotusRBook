
## Load relevant R packages {#loadPackages}

Before we begin working with data, we need to load the required packages. If you have not yet installed these packages (from github and CRAN) then please return to chapter 2 and do so.

```{r loadPackages, warning = FALSE, message = FALSE}

## required 'motus' packages from github
require(motus)
require(motusClient)
require(motusdata)

## required other packages from CRAN.
require(tidyverse)
require(lubridate)

## install, but don't load the plyr package; we use it directly for the 
## handy round_any function, but loading it can cause problems with the 
## dplyr functions. 

```


# Accessing and understanding detections data {#accessingData}

The success of the Motus network is dependent on the timely upload of detection data from receivers, and on the maintenance of accurate and up to date tag and receiver metadata by collaborators. After downloading your data from the Motus server, users are encouraged to check for updated detection data and metadata each time they run an analysis, because collaborators can add detection data and metadata at any time, and these could influence the completeness of your own detections data.


## Database types {#databaseTypes}

```{r fig3, echo = FALSE}

knitr::include_graphics("images/DataStructure.png")

```

<br>

There are two types of tag databases:

1. **receiver database**: includes all detections of any registered tags from a single receiver. A receiver database has a name like SG-1234BBBK5678.motus; where the name is the serial number of the receiver.

2. **project database**: includes all detections of your registered tags from across the motus network. A tag project database has a name like project-123.motus, where the number is the motus project ID.

These two databases correspond to the basic model of data sharing:

1. you get all detections of anyone's tags by *your* receivers (i.e., one receiver tag database for each receiver you deploy)

2. you get all detections of *your* tags by *anyone's* receivers (i.e., one project tag database for each of your motus projects)


## Importing tag detections {#importDetections}

To import tag detections for your project or receiver, you need a numerical project id or character scalar receiver serial number. 

### Download data for a project or receiver for the _first time_

When downloading data from the Motus server for the first time, you must specify update = TRUE and new = TRUE. Unless the directory that you want your data saved in is stated explicitly within the function call, data will be downloaded to the current working directory. 

## User Authentication {#userAuthentication}

Note that the first time you call a function using the Motus R package, you will be asked for your motus.org username and password to authenticate your access to project data. This will only happen once per R session. If you do not have a Motus user name and password, you can sign up at <https://motus.org/data/user/new>. Permission to access project data will then be granted by Motus staff or the project principal investigator.

Let's get started

```{r tagme1, eval = FALSE}

getwd() # to see the current working directory; use setwd() to change it.

t <- tagme(projRecv = 123, update = TRUE, new = TRUE)                # for project tag database
t <- tagme(projRecv = "SG-1013BB000626", update = TRUE, new = TRUE)  # for receiver tag database
```

Or specify a directory to create and open a local tag database using "dir = ":

```{r tagme2, eval = FALSE, message = FALSE, warning = FALSE}

t <- tagme(projRecv = 123, update = TRUE, new = TRUE, dir = "./data/") 

```

This will write a copy of your tag database to the working or specified folder, stored as an SQLite file with the extension '.motus'. 

### Update and open a local tag database

To open and update a detections database that already exists (has been downloaded previously):

```{r tagme2, eval = FALSE}

t <- tagme(projRecv = 123) ## if the file is in the local working directory, OR:
t <- tagme(projRecv = 123, dir = "./data/") ## use dir = to specify a directory

```

### Force an update/re-import of tag and receiver deployment metadata

Tag and receiver metadata are automatically merged with tag detections when data are downloaded. However, if you want to force a re-import of the metadata when updating a database, you can run:  

```{r tagme5, eval = FALSE}

t <- tagme(projRecv = 123, forceMeta = TRUE)

```

### Check if new data are available

To check if new data are available without downloading all of the previous data, you can use the tellme() function, which returns a list with:

- **numBatches**: number of batches of new data. 
- **numRuns**: number of runs of new tag detections, where a run is a series of continuous detections for a tag on a given antenna.
- **numHits**: number of new tag detections.
- **size**: approximate uncompressed size of data transfer required, in megabytes.

The following assumes that a local copy of the database already exists:

```{r tagme4b, eval = FALSE}

tellme(projRecv = 123)                    ## If db is in the working directory
tellme(projRecv = 123, dir = "C/Data/")   ## To specify a different directory

```

To check how much data is available for a project but you _do not_ have a database for it, use the 'new' parameter:

```{r tagme4c, eval = FALSE}

tellme(projRecv = 123)

```

## Data structure {#databaseStructure}

Each tag database is stored as an SQLite ('dplyr::src_sqlite') file with the extension '.motus'. The sqlite format was chosen because:

1. it is flexible, allowing for many data formats.
2. it is accessible from many software platforms (not just R).
3. it is **appendable**: the database can be created and updated on disk without having to read in and resave the entire contents. This will save time and computer memory when searching to see if any new detections are available for your project or receiver.

The .motus file contains a series of interelated tables where data are stored in a condensed format to save memory. The following tables are included in the .motus file; a complete list of variables stored in each table can be found in Appendix Table A1:

1. hits: detection data at the level of individual hits.
2. runs: detection data associated with a run (continuous detections of a unique tag on a given receiver).
3. batches: detection data for a given receiver and boot number.
4. batchRuns:
5. projBatch:
5. meta:
6. tags: metadata related to tags, e.g., unique identifier, tag characteristics (e.g., burst interval).
7. tagAmbig
8. tagDeps: metadata related to tag deployments, e.g., deployment date, location, and species.
9. recvs:
10. recvDeps: metadata related to receiver deployments, e.g., deployment date, location, receiver characteristics.
11. antDeps: metadata related to antenna deployments, e.g., deployment height, angle, antenna type.
12. species: metadata related to species, e.g., unique identifier, scientific name, common name.
13. projs: metadata related to projects, e.g., project name, principal investigator.
14. gps: metadata related to Geographic Positioning System (GPS) position of receiver. 
15. projAmbig: 

In addition to these tables, there are also 'virtual' tables, which are queries that merge data from the various tables into a single convenient 'view' that contains all of the fields you are likely to need. The following views are currently included in each .motus file:

1. alltags
2. allambigs
3. alltagswithambigs

Because the file is a dplyr::src_sqlite file, all of the dplyr functions can be used to filter and summarize the .motus database, without needing to first save the data as a *flat* file, i.e., a typical two-dimensional dataframe with every record for each field filled in. This is very advantageous when you have a large file -- the queries using SQL will be substantially faster. 

Each table in the .motus file can be accessed using the tbl() function. 

```{r getTable, eval = FALSE}

# get the tag deployment metadata view for the current project
tagMeta <- tbl(t, "tagDeps")
     
```

The underlying structure of these tables is a list of length 2:

```{r dfStructure, eval = FALSE}

str(tagMeta)

```

The first part of the list, 'src', is a list that provides details of the SQLiteConnection, including where the database is stored. The second part is a list that includes the underlying table. Thus, the R object 'tagMeta' is a *virtual* table that stores the database structure and information required to connect to the underlying data in the .motus file. As stated above, the advantage of storing the data in this way is that it saves memory when accessing very large databases, and the dplyr package can be used to manipulate and summarize the tables before collecting the results into a typical "flat" format dataframe.

If you want to use familiar functions to get access to components of the underlying data frame, then use the 'collect' function. For example:

```{r}

## look at the names of the variables
tagMeta %>% 
  collect() %>%
  names() # list the variable names in the table

```

The *virtual* table 'alltagswithambigs' contains the detection data, along with all variables that most users will ever need from the various underlying .motus tables. It too is accessed using the dplyr tbl() function:  

```{r getAllTagsTable, eval = FALSE}

vt <- tbl(t, "alltagswithambigs") ## virtual table

```

The following table lists the variables available in the 'alltagswithambigs' view, along with a description of each.

```{r parameterTable, echo = FALSE}

vt %>% 
  collect() %>%
  names()

```

## Convert a SQLITE table to a flat dataframe {#convertToFlat}

To convert the 'alltagswithambigs' view or other table into a typical 'flat' format, i.e., with every record for each field filled in, use the collect() and as.data.frame() functions.  The output can then be further manipulated. , or used to generate a RDS file of your data. 

We suggest that a good workflow is to prepare a script that downloads/updates your data, filters out the necessary variables, and saves the resulting data as an RDS file. We suggest using RDS instead of CSV, because the RDS format preserves the underlying structure of the data (e.g. POSIX times stay as POSIX times). If you want to export your data to another program, the a CSV format might be preferred.

We caution that producing a flat file using the full suite of fields can chew up a lot of memory, and can slow R down considerably when dealing with large datasets. This is the point in your workflow where you should remove any unwanted variables. You can always change your mind and return to this script, creating a new RDS file.

```{r collect, eval = FALSE}

df <- vt %>% 
  collect() %>% 
  as.data.frame()      ## for all fields in the df (data frame)

```

And take a quick look at the resulting file. 

```{r quickLook, eval = FALSE}

names(df)     ## field names
str(df)       ## Look at the structure of your data fields
head(df)      ## Look at first 6 rows of your df
summary(df)   ## summary of each column in your df

```

If you want to load only part of your entire virtual table (e.g. certain fields, certain tags, or all tags from a specified project or species), you can use dplyr funtions to filter the data before collecting into a dataframe.  Some examples are below:

1. To select certain fields:

```{r collect1, eval = FALSE}

## to grab a subset of fields, in this case a unique list of motus tag IDs 
## at each receiver and antenna.
df.subset <- select(vt, recv, ant, motusTagID) %>%
  distinct() %>% 
  collect() %>% 
  as.data.frame()     

```

2. To select certain tag IDs:

```{r collect2, eval = FALSE}
## filter to include only motusTagIDs 9939, 25643
df.subset <- filter(vt, motusTagID %in% c(16011, 23316)) %>% 
                  collect() %>% 
                  as.data.frame()   

```

3. To select a specified species:

```{r collect3, eval = FALSE}

## filter to only Red Knot (using speciesID)
df.subset <- filter(vt, speciesID == 4670) %>%  
  collect() %>% 
  as.data.frame()

## filter to only Red Knot (using English name)
df.subset <- filter(vt, spEN == "Red Knot") %>%   
  collect() %>% 
  as.data.frame()  

```

Using dplyr(), your virtual table can also be summarized before converting to a flat file. For example, to find the number of different detections for each tag at each receiver:

```{r collectSum, eval = FALSE}

df.hsum <- vt %>% 
  group_by(motusTagID, recv) %>%
  tally() %>%
  collect() %>%
  as.data.frame() 

```

In the next chapter we will show you additional ways of summarizing and working with your data.

## Export your 'flat' dataframe to CSV or RDS file {#exportDetections}

Good workflow is to create a script that deals with all of your data issues, then saves a dataframe (or workspace) for re-use. If you do this, you can quickly start an analysis or visualization session from a known (and consistent) starting point. When working in R, we do this is by using an RDS file, which preserves all of the associated R data structures (such as time stamps).

```{r createRDS, eval = FALSE, message = FALSE, warning = FALSE}

## save an RDS file
saveRDS(df.flat, "./data/df.flat.RDS")  

## or save as CSV file, which does not preserve time stamps, but is more universally accepted

write.csv(df.flat, "./data/df.flat.CSV", row.names = FALSE)

```

### Create function to output .motus tables to 'flat' dataframes {#flatRDSfunction}

For the purpose of this book, the following function creates flat CSV or RDS files of the various tables that we will need from the .motus file. You can run this function on your own data as it is, or modify it to include/exclude different fields in the various tables.

In this function, we include some basic data filters, create date and location variables, and select the variables that are likely to be of interest and use for most applications. This includes:

1. creating 'recvLat' and 'recvLon' variables, which default to using the latitude and longitude derived from the GPS in each receiver, and in-fills missing GPS values with the latitude and longitude from the receiver deployment metadata entered online by the project that deployed the station.

2. creating an 'ambig' variable, which assigns a '1' when the detections could belong to two or more (up to 6) duplicate tags.

3. providing filters for run length and standard deviation of frequency offset among pulses in a burst, which can give an indication of the probability that a detection is a false positive. Generally, detections with runLen <= 2 have a high probability of being false positive, as do detections with freqSD > 0.1  kHz. These filters are included, but not used here (see Chapter \@ref(dataCleaning)).

```{r dataFunction}

# for your own data, replace with location of your 'project-XX.motus' data

createFlatFiles <- function(out.dir, in.df, table.list, output.format) {  

  # load .motus file

  file.name <-  in.df 
  t <- dplyr::src_sqlite(file.name)

  # Loop through table.list, create flat file, and save to RDS file
  # An if() statement is included to select only certain parameters from the alltagswithambigs table
  # This can be modified to include different parameters, or to create a different if() statement for
  # another table.
  
  for(i in 1:length(table.list)) {
    
        df <- tbl(t, table.list[i])
       
        if(table.list[i] == "alltagswithambigs"){
        df <- mutate(df,  # create receiver Lat/Lon fields- use lat/lon from GPS, and if NA, use the lat/lon from the receiver deployment metadata
                     recvLat = if_else(is.na(gpsLat), recvDeployLat, gpsLat), 
                     recvLon = if_else(is.na(gpsLon), recvDeployLon, gpsLon),
                     # create an ambiguous column, so detections are labelled as ambiguous or not
                     ambig = if_else(is.na(ambigID), 0, 1))  %>% 
              # keep only parameters of interest. Could potentially drop gpsLat/Lon and recvDeployLat/Lon
              select(hitID, runID, batchID, ts, sig, sigsd, freqsd, motusTagID, ambigID, ant, 
                     runLen, tagProjID, tagDeployID, id, depLat, depLon, depAlt, recvDeployID, recvDeployLat,
                     recvDeployLon, recvDeployElevation, recv, site, projID, antType, antBearing, antHeight, 
                     spEN, spFR, spSci, tagProj, proj, gpsLat, gpsLon, gpsAlt, recvLat, recvLon, ambig) %>%
              # keep only run lengths greater than 2. This can be modified later, to see if any detections with
              # a run length of two are real detections.
          
              filter(runLen >=2) # note we are inlcuding 2 here; add: ", freqSD <= 0.1" to filter for freqSD as well.
          

        } # end of if statement
    
                           
   
        df <- df %>% 
              collect() %>% 
              as.data.frame()
  
        # once in a flat file, modify timestamp which is stored in the .motus file as seconds since Jan 01, 1970
        
        if(table.list[i] == "alltagswithambigs"){
            df <- mutate(df, 
                  ts = as_datetime(ts, tz = "GMT", origin = "1970-01-01"))
        } # end of if statement
        
        # modify times of tag and receiver deployment metadata
        
        if(table.list[i] == "tagDeps"|table.list[i] == "recvDeps"){
            df <- mutate(df, 
                  tsStart = as_datetime(tsStart, tz = "GMT", origin = "1970-01-01"), 
                  tsEnd = as_datetime(tsEnd, tz = "GMT", origin = "1970-01-01"))
        } # end of if statement
        
  if(output.format == "RDS") {     
  saveRDS(df, file = paste(out.dir, "df.", table.list[i], ".rds", sep = "")) 
  }
  
  if(output.format == "CSV") {     
  write.csv(df, file = paste(out.dir, "df.", table.list[i], ".csv", sep = ""), row.names = FALSE) 
  }     
     
  } # end of for loop
} # end of function
```

Run the function by first setting the parameters 'out.dir', 'in.df', and 'table.list':

```{r runDataRDSFunction, eval = FALSE}

# choose output format, choice of RDS or CSV:

output.format <- "RDS"

# directory where you want your flat RDS files to be stored 
out.dir <- paste(getwd(), "/data/", sep = "") # or change to the output directory of your choice

# full location of your .motus file. This will typically look like in.df <- "C:/Motus/data/project-xx.motus"
in.df <- system.file("extdata", "project-sample.motus", package = "motusdata") 

# list of tables in your .motus file that you want to transform to flat files:
table.list <- c("alltagswithambigs", "tags", "tagDeps", "recvs", "recvDeps", "antDeps", "species")

# run the function, which will output an RDS flat file for each table in the specified directory
createFlatFiles(out.dir = out.dir, in.df = in.df, table.list = table.list, output.format = output.format)

```

### Access the book sample dataset

For the purposes of this book, the sample data from the James Bay Shorebird Project (see Section \@ref(sampleData)) has been downloaded and the .motus and RDS files made available through the motusdata R package. You can use the following code to load the sample data:

```{r importSampleData, message = FALSE}

## to access the .motus file for the sample data contained in the motusdata package:

file.name <- system.file("extdata", "project-sample.motus", package = "motusdata") 
t <- dplyr::src_sqlite(file.name)

## to access the RDS tables:

** FILL THIS IN

```
