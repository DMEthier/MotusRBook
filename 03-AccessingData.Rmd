# Accessing and understanding detections data {#accessingData}

The success of the Motus network is dependent on the timely upload of detection data from receivers, and on the maintenance of accurate and up to date tag and receiver metadata by collaborators. Users are encouraged to check for updated detection data and metadata each time they run an analysis, because collaborators can add detection data and metadata at any time, and these could influence the completeness of your own detections data.

## Database types {#databaseTypes}

```{r fig3, echo = FALSE}

knitr::include_graphics("images/DataStructure.png")

```

<br>

There are two types of tag databases:

1. **receiver database**: includes all detections of any registered tags from a single receiver. A receiver database has a name like SG-1234BBBK5678.motus; where the name is the serial number of the receiver.

2. **project database**: includes all detections of your registered tags from across the motus network. A tag project database has a name like project-123.motus, where the number is the motus project ID.


These two databases correspond to the basic model of data sharing:

1. you get all detections of anyone's tags by *your* receivers (i.e., one receiver tag database for each receiver you deploy)

2. you get all detections of *your* tags by *anyone's* receivers (i.e., one project tag database for each of your motus projects)

## Load relevant R packages {#loadPackages}

```{r loadPackages, warning = FALSE, message = FALSE}

require(devtools)
require(tidyverse)

```

## Importing tag detections {#importDetections}

Your project's .motus file is available for download at <https://motus.org/data/downloads> under your project profile. Once downloaded, **make sure that you have the appropriate packages installed and loaded in R** (see Chapter \@ref(loadingPackages). 

Once all required packages are loaded, you can use the following code to load your project data, or the sample data from the James Bay Shorebird Project ('sampledb.motus'; see Section \@ref(sampleData)):

```{r importSampleData, message = FALSE}
## to access sample data contained in the motusdata package:
file.name <- system.file("extdata", "project-sample.motus", package = "motusdata") 
t <- dplyr::src_sqlite(file.name)
```

To load your own data you can run:

```{r importPersonalData, eval = FALSE, message = FALSE}
## to access your own data:
file.name <-  "C:/data/project-123.motus" #replace with the path to your data
t <- dplyr::src_sqlite(file.name)
```

## Data structure {#databaseStructure}

Each tag database is stored as an SQLite ('dplyr::src_sqlite') file with the extension '.motus'. The sqlite format was chosen because:

1. it is flexible, allowing for many data formats.
2. it is accessible from many software platforms (not just R).
3. it is **appendable**: the database can be created and updated on disk without having to read in and resave the entire contents. This will save time and computer memory when searching to see if any new detections are available for your project or receiver.

The .motus file contains a series of interelated tables where data are stored in a condensed format to save memory. The following tables are included in the .motus file; a complete list of parameters stored in each table can be found in Appendix Table A1:

1. hits: detection data at the level of individual hits.
2. runs: detection data associated with a run (continuous detections of a unique tag on a given receiver).
3. batches: detection data for a given receiver and boot number.
4. batchRuns:
5. projBatch:
5. meta:
6. tags: metadata related to tags, e.g., unique identifier, tag characteristics (e.g., burst interval).
7. tagAmbig
8. tagDeps: metadata related to tag deployments, e.g., deployment date, location, and species.
9. recvs:
10. recvDeps: metadata related to receiver deployments, e.g., deployment date, location, receiver characteristics.
11. antDeps: metadata related to antenna deployments, e.g., deployment height, angle, antenna type.
12. species: metadata related to species, e.g., unique identifier, scientific name, common name.
13. projs: metadata related to projects, e.g., project name, principal investigator.
14. gps: metadata related to Geographic Positioning System (GPS) position of receiver. 
15. projAmbig: 

In addition to these tables, there are also 'virtual' tables, which are queries that merge data from the various tables into a single convenient 'view' that contains all of the fields you are likely to need. The following views are currently included in each .motus file:

1. alltags
2. allambigs
3. alltagswithambigs

Because the file is a dplyr::src_sqlite file, all of the dplyr functions can be used to filter and summarize the .motus database, without needing to first save the data as a *flat* file, i.e., a typical two-dimensional dataframe with every record for each field filled in. 

Each table in the .motus file can be accessed using the tbl() function, for example:

```{r getTable, message = FALSE}

# tag deployment metadata
tagMeta <- tbl(t, "tagDeps")
head(tagMeta)           
tagMeta$ops$vars        

```

The underlying structure of these tables shows that each is a list of length 2:

```{r dfStructure}

str(tagMeta)

```

The first part of the list, 'src', is a list that provides details of the SQLiteConnection, including where the database is stored. The second part is a list that includes the names of the variables ('tagMeta$ops$vars') included in the  table. Thus, the R object 'tagMeta' is a *virtual* table that stores the database structure and information required to connect to the underlying data in the .motus file. As stated above, the advantage of storing the data in this way is that it saves memory when accessing very large databases, and the dplyr package can be used to manipulate and summarize the tables before collecting the results into a typical "flat" format dataframe.

The *virtual* table 'alltagswithambigs' contains all fields that most users will need from the various .motus tables, and can also be accessed using the dplyr tbl() function:  

```{r getAllTagsTable}

df <- tbl(t, "alltagswithambigs")

```

The following table lists the parameters available in the 'alltagswithambigs' table, along with a description of each parameter.

```{r parameterTable, echo = FALSE}

param.table <- dplyr::select(read.csv("./data/DatabaseParameters.csv"), 1:2)
knitr::kable(param.table, caption = "Description of fields in the tag detections database") 

```

### Convert a virtual table to a flat dataframe {#convertToFlat}

If you want your entire dataframe in a typical "flat" format, i.e., with every record for each field filled in, you can use the collect() function.  The output can then be used to generate a .rds or .csv file of your data. However, we caution that if you have a large data set, producing such a table using the full suite of fields can chew up a lot of memory and slow down your R session considerably:

To convert the 'alltagswithambigs' view or other table into a typical 'flat' format, i.e., with every record for each field filled in, use the collect() function.  The output can then be used to generate a .rds file of your data. We suggest using .rds instead of .csv, because the .rds format provides many advantages, including saving the environment (e.g., time zone), which means date/times don't need to be manipulated each time a file is loaded.  

We caution that producing a flat file using the full suite of fields can chew up a lot of memory, and can slow R down considerably when dealing with large datasets:

```{r collect}

df.flat <- df %>% 
  collect() %>% 
  as.data.frame()      ## for all fields in the df

```

```{r quickLook}

names(df.flat)     ## field names
str(df.flat)       ## Look at the structure of your data fields
head(df.flat)      ## Look at first 6 rows of your df
summary(df.flat)   ## summary of each column in your df

```

If you want to load only part of your entire data frame (e.g. certain fields, certain tags, or all tags from a specified project or species), you can use dplyr funtions to filter the data before collecting into a flat dataframe.  Some examples are below:

1. To select certain fields:

```{r collect1, eval = FALSE}

## to grab a subset of fields, in this case a unique list of motus tag IDs 
## at each receiver and antenna.
df.flat.subset <- select(df, recv, ant, motusTagID) %>%
  distinct() %>% 
  collect() %>% 
  as.data.frame()     

```

2. To select certain tag IDs:

```{r collect2, eval = FALSE}

df.flat.subset <- filter(df, motusTagID %in% c(16011, 23316)) %>%  ## filter to include only motusTagIDs 9939, 25643
                  collect() %>% 
                  as.data.frame()   

```

3. To select a specified species:

```{r collect3, eval = FALSE}

df.flat.subset <- filter(df, speciesID == 4670) %>%  ## filter to only Red Knot (using speciesID)
  collect() %>% 
  as.data.frame()   

df.flat.subset <- filter(df, spEN == "Red Knot") %>%   ## filter to only Red Knot (using English name)
  collect() %>% 
  as.data.frame()  

```

Using dplyr(), data can also be summarized before converting to a flat file. For example, to find the maximum signal strength of each tag in each hour by receiver:

```{r collectSum, eval = FALSE}

df.hourlySumm <- df %>% 
          mutate (hour = 3600 * round(ts / 3600, 0)) %>% 
          group_by(motusTagID, recv, hour) %>%
          summarize(
            max.sig = max(sig)) %>%
          collect() %>%
          as.data.frame()

```

### Export your "flat" dataframe to an RDS file {#exportToRDS}

A good workflow idea is to have a script that deals with all of your data issues, then saves a dataframe (or workspace) for re-use. If you do this, you can quickly start an analysis or visualization session from a known (and consistent) starting point. A good way to do this is by using an RDS file, which preserves all of the associated R data structures (such as time stamps).

```{r createRDS, eval = FALSE, message = FALSE, warning = FALSE}

## save an RDS file
saveRDS(df.flat, "./data/df.flat.RDS")  

```

## Function to convert .motus tables to RDS flat files

For the purpose of this book, the following function creates flat RDS files of the various tables that we will need from the .motus file. You can run this function on your own data as it is, or modify it to include/exclude different fields in the various tables. 

```{r dataFunction}

# for your own data, replace with location of your 'project-XX.motus' data

createFlatFiles <- function(out.dir, in.df, table.list) {  

  # load .motus file

  file.name <-  in.df 
  t <- dplyr::src_sqlite(file.name)

  # Loop through table.list, create flat file, and save to .rds file
  # An if() statement is included to select only certain parameters from the alltagswithambigs table
  # This can be modified to include different parameters, or to create a different if() statement for
  # another table.
  
  for(i in 1:length(table.list)) {
    
        df <- tbl(t, table.list[i])
       
        if(table.list[i] == "alltagswithambigs"){
        df <- select(df, hitID, runID, batchID, ts, sig, sigsd, freqsd, motusTagID, ambigID, ant, 
                              runLen, tagProjID, id, depLat, depLon, depAlt, recvDeployID, recvDeployLat,
                              recvDeployLon, recvDeployElevation, recv, site, projID, antType, antBearing, antHeight, 
                              spEN, spFR, spSci, tagProj, proj, gpsLat, gpsLon, gpsAlt)
        } # end of if statement
    
   
        df <- df %>% 
              collect() %>% 
              as.data.frame()
  
        # modify times and lat/lon of detections data
        
        if(table.list[i] == "alltagswithambigs"){
            df <- mutate(df, 
                  ts = as_datetime(ts, tz = "GMT", origin = "1970-01-01"),       
                  recvLat = if_else(is.na(gpsLat), recvDeployLat, gpsLat), 
                  recvLon = if_else(is.na(gpsLon), recvDeployLon, gpsLon))
        } # end of if statement
        
        # modify times of tag and receiver deployment metadata
        
        if(table.list[i] == "tagDeps"|table.list[i] == "recvDeps"){
            df <- mutate(df, 
                  tsStart = as_datetime(tsStart, tz = "GMT", origin = "1970-01-01"), 
                  tsEnd = as_datetime(tsEnd, tz = "GMT", origin = "1970-01-01"))
        } # end of if statement
        
       
  saveRDS(df, file = paste(out.dir, "df.", table.list[i], ".rds", sep = ""))
        
  } # end of for loop
} # end of function
```

Run the function by first setting the parameters 'out.dir', 'in.df', and 'table.list':

```{r runDataRDSFunction}

# directory where you want your flat .rds files stored 
out.dir <- paste(getwd(), "/data/", sep = "") # or change to the output directory of your choice

# full location of your .motus file. This will typically look like in.df <- "C:/Motus/data/project-xx.motus"
in.df <- system.file("extdata", "project-sample.motus", package = "motusdata") 

# list of tables you want to transform to flat files:
table.list <- c("alltagswithambigs", "tags", "tagDeps", "recvs", "recvDeps", "antDeps", "species")

# run the function, which will output an .rds file for each table in the specified directory
createFlatFiles(out.dir = out.dir, in.df = in.df, table.list = table.list)

```