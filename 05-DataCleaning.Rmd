# Data Cleaning {#dataCleaning}

Before analyzing your data, ambiguous and false positive detections should be filtered from the detection data. 

Ambiguous detections occur when two or more tags with the same Lotek ID code, burst interval, and nominal transmit frequency (i.e., the transmissions of tags are indistinguishable) are transmitting in the network at the same time, resulting in 'ambiguous' detections that could belong to either tag. In your .motus file, ambiguous detections are identified by a unique negative value in the 'ambigID' field of the alltags view. 

False positive detections occur as a result of background radio noise. Some sites will inherently have more background noise than others, and some tag IDs are more prone to false positives than others. 

## Load required packages

Follow the instructions in Chapter \@ref(loadingPackages) to install the following packages before loading, if you haven't already done so.

```{r loadpackages, message = FALSE, warning = FALSE}

library(devtools)
library(motus)
library(motusdata)
library(tidyverse)
library(lubridate)

```

## Load detection data and tag metadata

Recall from \@ref(accessingData) that when accessing the sample database, you will need to input "sample.motus" as both username and password when prompted by the tagme() user authentication process. 

When accessing the alltags table, we remove some variables that we do not currently need, and create receiver latitude and longitude variables that are based on the coordinates recorded by the receiver GPS, and where those are not available, infilled with coordinates from the receiver deployment metadata.

```{r importData5}

proj.num <- 176

# load detection data, select variables, create latitude variables, and transform to flat file
sql.motus <- tagme(proj.num)
tbl.alltags <- tbl(sql.motus, "alltags")
df.alltags <- tbl.alltags %>%
                mutate(recvLat = if_else((is.na(gpsLat)|gpsLat == 0), recvDeployLat, gpsLat),
                       recvLon = if_else((is.na(gpsLon)|gpsLon == 0), recvDeployLon, gpsLon),
                       recvAlt = if_else(is.na(gpsAlt), recvDeployAlt, gpsAlt)) %>%
                select(-noise, -slop, -burstSlop, -done, -bootnum, -mfgID, -codeSet, -mfg, -nomFreq, -markerNumber, -markerType, -tagDepComments, -fullID, -deviceID, -recvDeployLat, -recvDeployLon, -recvDeployAlt, -speciesGroup, -gpsLat, -gpsLon) %>%
                collect() %>%
                as.data.frame() %>%
                mutate(ts = as_datetime(ts)) # work with dates AFTER transforming to flat file


# load tag metadata, select variables of interest, and manipulate names of others

tbl.tagDeps <- tbl(sql.motus, "tagDeps")
df.tagDeps <- tbl.tagDeps %>%
                select(projectID, deployID, tagID, tsStart, tsEnd, latitude, longitude) %>% 
                distinct() %>%
                collect() %>%
                as.data.frame() %>%
                mutate(tagDeployStart = as_datetime(tsStart),
                   tagDeployEnd = as_datetime(tsEnd),
                   tagDeployLat = latitude, 
                   tagDeployLon = longitude) %>%
                select(-latitude, -longitude, -tsStart, -tsEnd)

# Load receiver metadata, for use later

tbl.recvDeps <- tbl(sql.motus, "recvDeps")
df.recvDeps <- tbl.recvDeps %>%
                select(projectID, deployID, name, siteName, status, isMobile, tsStart, tsEnd, latitude, longitude, elevation) %>% 
                distinct() %>%
                collect() %>%
                as.data.frame() %>%
                mutate(recvDeployStart = as_datetime(tsStart),
                   recvDeployEnd = as_datetime(tsEnd),
                   recvDeployLat = latitude, 
                   recvDeployLon = longitude) %>%
                select(-latitude, -longitude, -tsStart, -tsEnd)

```

## Preliminary data checks

### Check number of tags with detections

First, check how many project tags have detection data. There are several reasons why deployed tags might not have detections, including:

1) the tag was not properly activated on deployment. To avoid this, always check that a tag is active using a hand-held receiver before attaching the tag to your study animal and releasing it. 

2) an animal with a properly activated tag might not pass within range of a receiving station. Study designs that incorporate strategic placement of receivers to meet project goals can improve your odds of getting detections of your tags.

3) missing or incorrect tag deployment metadata can result in the tagFinder not 'looking' for your tag at the time the tag was deployed, or at all. 

For this check, subset the detection data to include only those tags registered to the sample project; i.e., we exclude ambiguous detections associated with duplicate tags from other projects:

```{r ntagsDetections}

df.alltags %>%
  filter(tagProjID == proj.num) %>%
  select(motusTagID) %>%
  distinct() %>%
  summarize(nTags = n()) # if you want to see the list of motusTagIDs, replace summarize(nTags =n()) with as.list()

```
In the sample dataframe, there are detections for 18 tags deployed by the sample project.

### Check number of tags with ambiguous detections

The clarify() function in the motusClient R package provides a summary of ambiguities in the detection data. Each ambigID refers to a selection of detections that could belong to one or more (up to 6) motusTagIDs, which are listed in the clarify table:

```{r checkForAmbigs}

clarify(sql.motus) 

```

Note that detections associated with five of the six ambigIDs could belong to one of two tags, and detections associated with one ambigID (-171) could belong to one of three tags. 

For the purpose of this chapter, we simplify the sample and tag deployments dataframes by subsetting the data to six motusTagIDs:  four tags (motusTagID = 22897, 22905, 23319, 22902) are associated with ambiguous detections (ambigID = -114, -134, -171), and two tags (16038, 16047) do not have ambiguous detections.

```{r subsetTags}

tag.list <- c(22897, 22905, 23319, 22902, 16038, 16047)
ambig.list <- df.allambigs$motusTagID[df.allambigs$ambigID %in% c(-114, -134, -171)]

# subset detections data to the tags of interest from our project
df.alltags.sub <- df.alltags %>%
                    filter(motusTagID %in% tag.list)

# subset deployment records to tags of interest and any duplicate tags.
df.tagDeps.sub <- df.tagDeps %>%
                    filter(tagID %in% tag.list|tagID %in% ambig.list)

```

### Plot tag paths, including ambiguous/false detections

Before filtering ambiguous and false detections from the data, take a look at the paths of each tag, to get an idea of where detections occurred, and which of those detections are ambiguous.

To do so: 

1. Summarize order the data by tag and time stamp, and select data by date (ignoring time of day for this purpose).

```{r plotTagPaths}

df.alltags.path <- df.alltags.sub %>%
                    mutate(date = as_date(ts)) %>%
                    arrange(motusTagID, ts) %>%
                    filter(tagProjID == proj.num) %>%
                    select(motusTagID, date, ambigID, tagDepLon, tagDepLat, recvDepName, port, antBearing, recvLat, recvLon) %>%
                    distinct()

```

2. **Install R mapping package.**

If you do not have rworldmap installed then you must install and then load the package:

```{r installMapPackages, eval = FALSE, message = FALSE, warning = FALSE}

install.packages("rworldmap")
require(rworldmap)

```

3. **Load base map files.**

```{r loadMaps}

na.lakes <- map_data(map = "lakes")
na.lakes <- mutate(na.lakes, long = long- 360)

# Include all of the Americas to begin
na.map <- subset(map_data(map="world2"), 
                 region %in% c("Canada", "USA", "Mexico", "lakes",
                               "Belize", "Costa Rica", "Panama", 
                               "Guatemala", "Honduras", "Nicaragua", 
                               "El Salvador", "Colombia", "Venezuela", "Ecuador", "Peru", "Brazil",
                               "Guyana","Suriname", "Bolivia", "French Guiana", "Jamaica", "Cuba", 
                               "Haiti", "Dominican Republic", "The Bahamas", "Turks and Caicos Islands", 
                               "Puerto Rico", "British Virgin Islands", "Montserrat", "Dominica", "Saint Lucia", 
                               "Barbados", "Grenada", "Trinidad and Tobago", "Chile", "Argentina", "Uruguay", "Paraguay"))

na.map <- mutate(na.map, long = long- 360)

```

4. **Map the paths of tag detections.**

The location of ambiguous detections are shown by black 'x', and the deployment location of all duplicate tags are shown by coloured circles:

```{r mapDetections}

# set limits to map based on locations of detections, ensuring they include the deployment locations
xmin <- min(df.alltags.path$recvLon, na.rm = TRUE) - 2
xmax <- max(df.alltags.path$recvLon, na.rm = TRUE) + 2
ymin <- min(df.alltags.path$recvLat, na.rm = TRUE) - 2
ymax <- max(df.alltags.path$recvLat, na.rm = TRUE) + 2
                
# map
ggplot(na.lakes, aes(long, lat))+ 
  geom_polygon(data = na.map, aes(long, lat, group=group), colour = "grey", fill="grey98")+#
  geom_polygon(aes(group = group), colour = "grey", fill = "white")+
  coord_map(projection="mercator", xlim = c(xmin, xmax), ylim = c(ymin, ymax))+
  xlab("") + ylab("") + 
  theme_bw() + 
  geom_path(data = df.alltags.path, aes(recvLon, recvLat, group = motusTagID), colour = "grey20") + 
  geom_point(data = df.alltags.path, aes(recvLon, recvLat, colour = !is.na(ambigID), shape = !is.na(ambigID)), size =1.5)+
  geom_point(data = df.alltags.path, aes(tagDepLon, tagDepLat), colour = "black", shape = 4) +
  scale_colour_discrete("motusTagID") +
  scale_shape_manual(values = c(1, 2)) +
  scale_colour_manual(values = c("deepskyblue3", "darkorange1"))+
  facet_wrap(~motusTagID, nrow = 2)

```
**Figure 1.** Plot of the paths of several tags, showing ambiguous detections (orange triangles), non-ambiguous detections (blue circles), and the deployment location of the tag (black 'x'). Some of the ambiguous detections likely belong to the tags, and some non-ambiguous detections could be false positives. By the end of this chapter, we will show how to filter ambiguous and false positive detections that do not belong to these tags.

We see from the plots that 22905 and 23319 are duplicate tags, and share ambiguous detections, shown by the orange triangles in the above plot.

## Filter Data

At the end of this section, we will have a list of hitIDs associated with:

1) ambiguous detections that *do not* belong to our tag(s), and

2) false positive detections that *do not* belong to out tag(s).

This list will be used to filter the detection data to exclude detections that are deemed ambiguous or false positive. We approach this problem using the following steps. 

1) For ambiguous detections, check to see how much deployment dates overlap. Many ambiguous detections arise because tags overlap just a little at the beginning or end of their estimated lifespan. 

2) If there is a lot of overlap ...

3) Some tags we cannot do anything about, so we don't claim them. 

### Check geographic position (latitude/longitude) against time

First, we visualize the time and location of detections relative to the time and location of tag deployments. Note that if you have a large number of tags (say > 6) in your data, these plots will be messy. Instead, use the loop in 3) below to output tag-specific plots to PDF files. The coloured points are the tag deployment locations and date, the open black circles are the ambiguous detections associated with those tags.

When we plot the data, we want to include the deployment date and location of any duplicate tag, so we can visualize where detections fall relative to the tag deployments. Because we are plotting with a facet based on motusTagID, and not ambigID, we need to first manipulate the data, so that we end up with a deployment metadata table that has a 'tagID' variable which tells us which motusTagID the deployment information belongs to, and a 'motusTagID' field which tells us which of our tags this deployment information should be plotted with (i.e., which tag it is a duplicate of). [THERE MUST BE A BETTER WAY?!!]

```{r importTagMeta}

## get a list of the motusIDs for all of ambiguous IDs
df.allambigs <-  tbl(sql.motus, "allambigs") %>%
  #filter(motusTagID %in% tag.list) %>%
  collect() %>% 
  as.data.frame() 

df.myAmbigs <- df.allambigs %>%
  filter(motusTagID %in% tag.list)

# deployments in this table are the deployments of the duplicate tags (motusTagDup)
df.myDeps <- left_join(df.tagDeps.sub,
                          df.allambigs,
                          by = c("tagID" = "motusTagID"))

## merge again, creating a new variable with both the projectID
## and the MotusTagID which makes it easier for plotting to see where
## the various ambiguous come from.
df.myDeps <- left_join(df.myDeps, df.myAmbigs, by = "ambigID") %>%
  mutate(plot.id = paste(ambigID, tagID, projectID, sep = "."),
         motusTagID = if_else(is.na(motusTagID), tagID, motusTagID))

```

1. **Plot latitude of ambiguous detections against time.**

```{r plotLatbyTime, fig.width=11, fig.height=6}

ggplot(data = filter(df.alltags.sub, is.na(ambigID)), # plot ambiguous detections first
            aes(ts, recvLat)) +
  geom_point(size = 1, shape = 1) +
  geom_point(data = filter(df.alltags.sub, !is.na(ambigID)), aes(ts, recvLat), size = 1, shape = 2) + # add non-ambiguous detections
  geom_point(data = df.myDeps, aes(tagDeployStart, tagDeployLat, colour = plot.id), size = 2, shape = 13) +
  facet_wrap(~ motusTagID, ncol= 3, scales = "free") + 
  theme_bw() +   
  ylab("Latitude") + xlab("Date") +
  guides(colour=guide_legend(title="id.motusTagID.projectID")) 

```
2. **Plot longitude of ambiguous detections against time.**

```{r plotLonbyTime}


ggplot(data = filter(df.alltags.sub, is.na(ambigID)), # plot ambiguous detections first
            aes(ts, recvLon)) +
  geom_point(size = 1, shape = 1) +
  geom_point(data = filter(df.alltags.sub, !is.na(ambigID)), aes(ts, recvLon), size = 1, shape = 2) + # add non-ambiguous detections
  geom_point(data = df.myDeps, aes(tagDeployStart, tagDeployLon, colour = plot.id), size = 2, shape = 13) +
  facet_wrap(~ motusTagID, ncol= 3, scales = "free") + 
  theme_bw() +   
  ylab("Longitude") + xlab("Date") +
  guides(colour=guide_legend(title="id.motusTagID.projectID")) 

```
**Ambiguous Detections:**

- 22897 (ambigID -144): ambiguous detections do not belong to our tag, and can be dropped.
- 22902 (ambigID -171): ambiguous detections in 2017 either do not belong to our tag (> 40 degrees latitude), or could belong to one of two tags. Because there is no way to decipher which tags they might belong to, all ambiguous detections in 2017 will be dropped.
- 22905/23319 (ambigID -134): in this case, duplicate tags were deployed by the James Bay Shorebird Project, and deploment periods overlap almost entirely.  As a result, we really can't say which tag the ambiguous detections belong to, and they will unfortunately be dropped for both tags. 

We create a list of runIDs and drop these detections:

```{r runID1}

# tag 22897
runID.list1 <- df.alltags.sub %>%
  filter(!is.na(ambigID),
         motusTagID == 22897) %>%
  select(runID) %>%
  distinct()

# tag 22902
runID.list2 <- df.alltags.sub %>%
  filter(!is.na(ambigID),
         motusTagID == 22902,
         year(ts) == 2017) %>%
  select(runID) %>%
  distinct()

# tags 22905/23319
runID.list3 <- df.alltags.sub %>%
  filter(ambigID == -134) %>%
  select(runID) %>%
  distinct()
  
runID.list <- rbind(runID.list1, runID.list2, runID.list3)

# and now drop these from the data:

df.alltags.sub <- df.alltags.sub %>%
  filter(!(runID %in% runID.list$runID))


```

If you now re-run the above lat/lon plots, they are already looking much cleaner.

### Check run length

Run length ('runLen') is the number of tag bursts in a run, and a run is a group of consecutive detections of a tag detected on a receiver. In general, a detection with a run length of 2 or less has a high probability of being a false detection. Filtering by run length can therefore be an efficient way to filter out false positive detections. We caution, however, that filtering out all detections with a run length of <= 2 has the potential to also filter out true detections. We therefore recommend that you examine which detections this filter would remove.

We repeat the above latitude/longitude by time plots, this time highlighting run length, to determine whether some of the outlying points in each graph are likely to be false positive:

1. **Plot latitude of ambiguous detections against time.**

```{r plotLatbyTime, fig.width=11, fig.height=6}

ggplot(data = df.alltags.sub, aes(ts, recvLat, shape = as.factor(runLen > 2))) +
  geom_point(size = 1) +
  geom_point(data = filter(df.myDeps, projectID == 176), aes(tagDeployStart, tagDeployLat, colour = plot.id), size = 2, shape = 13) +
  facet_wrap(~ motusTagID, ncol= 3, scales = "free") + 
  theme_bw() +   
  ylab("Latitude") + xlab("Date") +
  guides(colour=guide_legend(title="id.motusTagID.projectID")) +
  scale_shape_manual(values = c(1, 2))

```
2. **Plot longitude of ambiguous detections against time.**

```{r plotLonbyTime}

ggplot(data = df.alltags.sub, aes(ts, recvLon, shape = as.factor(runLen > 2))) +
  geom_point(size = 1) +
  geom_point(data = filter(df.myDeps, projectID == 176), aes(tagDeployStart, tagDeployLon, colour = plot.id), size = 2, shape = 13) +
  facet_wrap(~ motusTagID, ncol= 3, scales = "free") + 
  theme_bw() +   
  ylab("Longitude") + xlab("Date") +
  guides(colour=guide_legend(title="id.motusTagID.projectID")) +
  scale_shape_manual(values = c(1, 2))

```

A few things come out from these plots:

- 16038: the lone detection at lat < 42.5 in August/September can be dropped. The detections with run length <=2 after December might also be spurious, but at least one of those detections has a run length > 2, so we will take a closer look at those before dropping any.

- 16047: Detections after December occur independently and because run length <= 2, have a high probability of being false positive. We drop these from the data.

- 22897: There looks to be a series of detections with run length <= 2 at a receiver with latitude ~ 40  and longitude ~ -79, which are likely the result of a 'noisy' station, which is generating false positive detections.To find the station deployment data, we subset the detections to those from January (this was the only station with detections in January), see that the receiver deployment name is 'PARC Shady Nook'. This is a site in interior Pennsylvania, which is an unlikely location to detection a Red Knot, so we can delete all detections from this station. The remainder of the detections with run length <= 2 can likely also be dropped, but we will take a closer look at those.

- 22902: 


```{r check1}

filter(df.alltags.sub, motusTagID == 22897, month(ts) == 1)

```






### Check flight speed between detections {#filterFlightSpeed}

By looking at the rate of movement between sites with consecutive detections, we can often quickly view flights that are not physically possible. 

Rate of movement between sites can be determined using the siteTrans function in the motus R package.  

```{r falseBySpeed1, message = FALSE, warning = FALSE}

df.detectTrans <- as.data.frame(siteTrans(df.alltags.sub)) ## create new data.base consisting of transitions between consecutive sites for each tag
head(df.detectTrans)
filter(df.detectTrans, rate > 60)

df.detectTrans %>%
  group_by(motusTagID) %>%
  summarize()
```

Results are in meters (distance) or meters/second (rate), and most of the recorded rates are reasonable, however there are several with flight speeds of greater than 83 m/s (298 km/hr), and up to 1777 m/s (6397 km/hr)!

Tag 16047 has lots of high speeds due to close towers, whereas 16038 has high speeds due to false detections.

The resulting database JBtrans shows information on the last detection at site x, and the first detection at site y.  In the above table, we can see the total time, distance, rate of movement, bearing, and rhumbline_bearing of potential flights between sites.  Rate of movement is presented as m/s.
Because rate of movement is based on receiver location at the time of last and first detection at two sites, it is only an estimation and sites closer together will have less accurate results.  For example, lets look at row 58 from JBtrans:

```{r falseBySpeed2, message = FALSE, warning = FALSE}

JBtrans[58,]

```

It would appear that the bird is travelling at a rage of 2203.543 m/s (7,932 km/hr)!  Based on rate alone you may think this is due to false detections, however the two sites are only 22km apart, and the time between detections was only 10 seconds.  This high estimated rate of movement is likely due to the tag being detected at the edge of the detection range of both receivers; remember we do not know how far the tag is from the receiver location at time of detection.
It's therefore important to take all information into consideration when looking at high rates of movement.  Let's look at all cases of high rates of movements, we can be conservative and only look at rates > 50 m/s

```{r falseBySpeed3, message = FALSE, warning = FALSE}

filter(JBtrans, rate > 50)

```

Almost all of these flights are between stations that are < 30 km apart so high rates of movement are not surprising.  Only one flight had an impossible rate of movement with stations far apart:

```{r falseBySpeed4, eval = FALSE, message = FALSE, warning = FALSE}

filter(JBtrans, rate > 50 & dist > 40000)

```

Not surprisingly, this is the same tag we identified as having false positives when examining latitudinal plots above.  We can confirm the hitID's by making the same plots as above, or similar ones identifying site name:

```{r falseBySpeed5,  message = FALSE, warning = FALSE}

ggplot(filter(JBraw, motusTagID == 16038), aes(ts, lat, col = as.factor(site))) + geom_point()

```

We can see that the detections at Illini State Park are the spurious detections, so to determine their hitIDs we can filter by site:

```{r falseBySpeed6, eval = FALSE, message = FALSE, warning = FALSE}

filter(JBraw, motusTagID == 16038 & site == "Illini State Park ")

```

Once again we determine that we should remove hitID's 239875440 - 239875445.


### Check overlap of deployment dates 

If the deployment periods of duplicate tags includes the tail end of the lifespan of one tag and the begining of the deployment of another, it is more likely that detections belong to the latter tag. 

As a first step, we therefore compare deployment start and end dates for each of the motusTagIDs that an ambigID might represent. To do so, we first subset the tag deployment metadata to the list of motusTagIDs associated with the ambigIDs. Since we did not fix the positive longitude online, we again notice it appear in the tag metadata and must fix that here as well.  This highlights why it is important to make metadata changes online rather than through R if the problem occurs in your data:

```{r importTagMeta}

## make a list of motusTagIDs that are associated with those ambigIDs - note these include motusTagIDs of duplicate tags from other projects

tbl.allambigs <-  tbl(sql.motus, "allambigs") 
df.allambigs <- tbl.ambigTags %>%
  collect() %>% 
  as.data.frame() 

## make a list of ambigIDs associated with our subset of data
ambig.list <- unique(df.alltags.sub$ambigID)

## update tag list to include duplicate tagIDs
tag.list <- df.allambigs %>%
                filter(ambigID %in% ambig.list) %>%
                select(motusTagID)
              
## Use this list to filter the tag metadata. We do this so that we can plot the deployment location and deployment start and end times of duplicate tags

df.tagDeps.sub <- df.tagDeps %>%
                filter(tagID %in% tag.list$motusTagID)

## and merge the two creating a new variable with both the projectID
## and the MotusTagID which makes it easier for plotting to see where
## the various ambiguous come from.

df.allambigs <- left_join(df.allambigs, 
                          df.tagDeps.sub, 
                          by = c("motusTagID" = "tagID")) %>%
  mutate(plot.id = paste(ambigID, motusTagID, projectID, sep = "."))
```

```{r}

## derives some summary data for the ambiguous detections to compare with the
## tag deployments

df.detectRange <- select(df.alltags.sub, ambigID, ts, 
                         recvLat, recvLon, runLen) %>%
#  mutate(date = date(as_datetime(ts))) %>%
  group_by(ambigID) %>% 
  summarize(detectStart = min(ts), 
            detectEnd = max(ts), 
            startLat = recvLat[ts == detectStart][1],
            startLon = recvLon[ts == detectStart][1], 
            endLat = recvLat[ts == detectEnd][1],
            endLon = recvLon[ts == detectEnd][1], 
            maxLat = max(recvLat, na.rm=TRUE), 
            maxLon = max(recvLon, na.rm=TRUE), 
            minLat = min(recvLat, na.rm=TRUE), 
            minLon = min(recvLon, na.rm=TRUE), 
            maxrunLen = max(runLen, na.rm=TRUE))

## maybe do a daily detections here?
```

From this, we want to examine the deployment start and end dates (depStart/depEnd), start and end locations (tagDepLat/tagDepLon), and the start and end dates of ambiguous detections (detectStart/detectEnd) associated with each ambigID/motusTagID:

```{r examineDeployments}

df.ambigTags <- full_join(df.ambigTags, df.detectRange, 
                          by = c("ambigID"))# %>%
  mutate(tsStart = as_datetime(tsStart), 
         tsEnd = as_datetime(tsEnd), 
         detectStart = as_datetime(detectStart), 
         detectEnd = as_datetime(detectEnd))

p <- ggplot(data=tmp, aes(tsStart, plot.id, 
                          group=ambigID, colour=factor(ambigID)))
p + geom_segment(aes(x=tsStart, xend=tsEnd, y=plot.id, yend=plot.id)) +
  geom_point(aes(detectStart, plot.id), pch=1, size=3) + 
  geom_point(aes(detectEnd, plot.id), pch=13, size=3) 
  
```

We can see make the following observations from the plot:

Ambiguous tags 337 and 106 are easy. The detections overlap towards the very end of the life of the previous tags, and so probably represent tags from the present project, that are still 'alive' in the previous project. None-the-less, we should still allow for the possibility that they are true overlaps. 

- ambigID -337: detections occur on the last day of the deployment for motusTagID 10811, so detections most likely belong to motusTagID 16011. 
- ambigID -106: detections occur near the end of the deployment for tag 17021, and one month after the deployment of 17357. Detections most likely belong to the latter tag.

- ambigID -114: deployment periods overlap, so detections could belong to either tag, but detections begin a week after the deployment of 24298 (and several months after the deployment of 22897).

- ambigID -171: detections occur near the end of the deployment period for 22902, and most likely belong to either 22778 or 24303. 

- ambigID -134: deployment periods for both tags overlap almost exactly, but begin on the day following deployment of 23319, which suggests they might belong to that tag. However, because they were both released at the same site, we really can't say which tag the detections belong to. In this case, checking the metadata confirms that indeed, two identical tags were released, and there's unfortunately not much that can be done in this case.  Because we can't assign the detections with certainty to either tag, detections associated with ambigID -134 will be delected for the detections data. Note that metadata and field notes should also be checked, since there may be other ways to assign the detections to a tag (for example if the first tag was on a bird that did not survive, or the tag fell off before the second tag was deployed).


- ambigID -56: deployments overlap, and detections could belong to either tag, but begin two days after 23316 was deployed, and one month after 22867 was deployed.






```{r joinTagMeta}



```





### Check standard deviation of frequency offset

Standard deviation of frequency offset among pulses in a burst ('freqsd'; in KHz) can also be used as a coarse and automatic data filter, by removing any values larger that 0.1, which suggests a false detection. This filter applies to data collected by Sensorgnome receivers only. As with run length, it is recommended that you identify the detections you would be removing and examine them to ensure you aren't removing an unwanted amount of true detections.

We create the same plot as for run length above:

```{r freqsd1}

ggplot(df.detections, aes(y = recvLat, x = recvLon, colour = as.factor(if_else(freqsd > 0.1, 1, 0)))) +
  geom_point() +
  theme_bw() +
  scale_colour_manual(values = c("red", "black"))

```

```{r freqsd2}

ggplot(df.detections, aes(y = recvLat, x = ts, colour =  as.factor(if_else(freqsd > 0.1, 1, 0)))) +
  geom_point() +
  theme_bw() +
  scale_colour_manual(values = c("red", "black"))

```









## Everything that follows is old.
## Plot detections with deployment dates 


## Check run length of outlying detections.

If you have a large number of ambiguities remaining, you may want to skip this step and go directly to mapping the detections.

Run length of a hit tells you how many consecutive bursts were detected by a receiver. The longer the run length, the more likely your detection is not a false positive (see Chapter \@ref(dataCleaning)). Any outlying detections should be checked for run length, and in general anything under a run length of 3 has a higher potential of being false positive. 
There are one or two detections at southern latitudes for ambigID -171 that we will check:

```{r check171ambig}

filter(ambig.df, ambigID == -171, recvLat < 10) %>% select(ts, sig, ambigID, runLen, site, proj, recvDeployLat, recvDeployLon) %>% distinct()

```

All detections associated with ambigID -171 occurred in forested habitats at a Motus station in interior Colombia. It is possible that the shorebirds were detected migrating overhead, although the detections have a runLen of only 2, and in the next section, we will see that the timing of the later detections on June 17th don't correspond with the potential detection of this tag in Delaware Bay on June 3rd. We will therefore assume these detections belong to other tags or are false positives.  

## Map ambiguous detections

Next we will map the detections associated with ambigID -56 and -171. We will then show you how to loop through the ambigIDs to output maps to file. 

1. **Install R mapping package.**
If you do not have rworldmap installed then you must run:
```{r installMapPackages, eval = FALSE, message = FALSE, warning = FALSE}

install.packages("rworldmap")

```
Once packages are installed, load it into R:
```{r loadMapPackages}

require(rworldmap)

```

2. **Load base map files.**

```{r loadMaps}

na.lakes <- map_data(map = "lakes")
na.lakes <- mutate(na.lakes, long = long- 360)

# Include all of the Americas to begin
na.map <- subset(map_data(map="world2"), 
                 region %in% c("Canada", "USA", "Mexico", "lakes",
                               "Belize", "Costa Rica", "Panama", 
                               "Guatemala", "Honduras", "Nicaragua", 
                               "El Salvador", "Colombia", "Venezuela", "Ecuador", "Peru", "Brazil",
                               "Guyana","Suriname", "Bolivia", "French Guiana", "Jamaica", "Cuba", 
                               "Haiti", "Dominican Republic", "The Bahamas", "Turks and Caicos Islands", 
                               "Puerto Rico", "British Virgin Islands", "Montserrat", "Dominica", "Saint Lucia", 
                               "Barbados", "Grenada", "Trinidad and Tobago"))

na.map <- mutate(na.map, long = long- 360)

```

3. **Map the locations of detections for a single ambigID.**

When we subset the data for the ambigID of interest, we will order the detections by timestamp.

```{r duplicateEx56}

aID <- -56  # assign ambigID of interest

dup.df <- filter(ambig.df, motusTagID %in% allAmbigs$motusTagID[allAmbigs$ambigID == aID]) %>%
              select(hitID, runID, batchID, ts, sig, ambigID, recvDeployID, site, recvLat, recvLon, gpsAlt, yr, dmy) %>%
              distinct() %>% 
              arrange(ts)

dup.depl <- filter(allAmbigs, ambigID == aID)
              
```

And now map the data. The location of ambiguous detections are shown by black 'x', and the deployment location of all duplicate tags are shown by coloured circles:

```{r mapDetections}

# set limits to map based on locations of detections, ensuring they include the deployment locations
xmin <- if_else(min(dup.df$recvLon) < min(dup.depl$tagDepLon), min(dup.df$recvLon) - 2, min(dup.depl$tagDepLon) - 2)
xmax <- if_else(max(dup.df$recvLon) > max(dup.depl$tagDepLon), max(dup.df$recvLon) + 2, max(dup.depl$tagDepLon) + 2)
ymin <- if_else(min(dup.df$recvLat) < min(dup.depl$tagDepLat), min(dup.df$recvLat) - 2, min(dup.depl$tagDepLat) - 2)
ymax <- if_else(max(dup.df$recvLat) > max(dup.depl$tagDepLat), max(dup.df$recvLat) + 2, max(dup.depl$tagDepLat) + 2)
                
# map
ggplot(na.lakes, aes(long, lat))+ 
  geom_polygon(data = na.map, aes(long, lat, group=group), colour = "grey", fill="grey98")+#
  geom_polygon(aes(group = group), colour = "grey", fill = "white")+
  coord_map(projection="mercator", xlim = c(xmin, xmax), ylim = c(ymin, ymax))+
  xlab("") + ylab("") + 
  theme_bw() + 
  geom_point(data = dup.df, aes(recvLon,recvLat), cex = 0.8, colour = "black", pch = 4)+
  geom_point(data = dup.depl, aes(tagDepLon,tagDepLat, colour = as.factor(project.motusTagID)), pch = 1, size = 3)+
  scale_colour_discrete("Deployment Location (projectID.motusTagID)")

```
### Map of ambigID -56

There are a few things we can tell from the map for *ambigID -56*:

1. there is an issue with the plotting of the map (a blank band through James Bay) that we will ignore for now!
2. detections with latitude > 45 and longitude < -75 belong to the tag deployed in the James Bay region (motusTagID = 22867).
3. detections with latitude > 45 and longitude > -75 belong to the tag deployed in the St. Lawrence region (motusTagID = 23316).
4. the remaining detections could belong to either tag, but we will filter out the remaining ambiguous detections and take a closer look at the timeline before we come to any determination about whether to drop those detections due to remaining ambiguities.

If you look again at the plot of latitude against time created earlier for ambigID -56, we see that detections in early October correspond to the departure and southward migration of motusTagID 22867. The later detection(s) in November look to correspond with the southern migratory departure of motusTagID 23316 from the St. Lawrence region. We can see the exact dates of the detections that occurred in 2016 below 45 degrees latitude using:

```{r filterDates}

filter(ambig.df, ambigID == -56, yr == 2016, recvLat < 45) %>% group_by(dmy) %>% summarize(nDetect = n())

```

From this, we can quite confidently assign detections in 2016 that have latitude < 45 and dmy < 2016-11-01 to tag 22867, and the remaining 2016 detections to tag 23316. We first double check to make sure the more southern detections occurred AFTER detections at higher latitudes for tag 22867 using the following code, which we don't evaluate here:

```{r filterDates2, eval = FALSE}

filter(ambig.df, motusTagID == 22867, yr == 2016, recvLat > 45, recvLon < -75) %>% group_by(ts, dmy) %>% summarize(nDetect = n())

```

If we take an even closer look at the actual timestamps of the detections, the last detection north of 45 degrees latitude was at 00:00:42 GMT, and the first detection at the more southern sites along the flyway were at 14:33:38 on the same day, which supports that the bird was actively migrating.

Unfortunately, because both tags could have been active during the following spring (all 2017 detections), we are unable to distinguish which bird these additional ambiguous detections belong to, and all 2017 detections will be dropped from the data.

### Map of ambigID -171

If we re-run the mapping code but assign `r aID <- -171`, we can see that the detections by the Fortescue site in Delaware Bay on June 3, 2017, are likely to be from our bird:

```{r map-171, echo = FALSE}

knitr::include_graphics("images/AmbigMap-171.png")

```

You can see details of the Delaware Bay detection by running the following (not evaluated here):

```{r delawareDetections, eval = FALSE}

filter(ambig.df, ambigID == -171, recvLat > 10 & recvLat < 40) %>% select(hitID, ts, sig, ambigID, runLen, site, proj, recvDeployLat, recvDeployLon)

```

3. **Write map of ambiguous detections to file.**

If you have a large number of ambiguous detections that you want to map, you can use this loop instead, which will output a PDF map for each ambigID in your data. If you are using your own data, replace the tagProjID in the first line with the ID number for your own project.

```{r mapAllAmbigs, eval = FALSE}

projID <- 38

for(i in 1:length(ambig.list)) {

dup.df <- filter(ambig.df, ambigID == ambig.list[i] & tagProjID == projID) %>%
              select(hitID, runID, batchID, ts, sig, ambigID, recvDeployID, site, recvLat, recvLon, yr, dmy) %>%
              distinct() %>% 
              arrange(ts)

dup.depl <- filter(allAmbigs, ambigID == ambig.list[i])
              
# set limits to map based on locations of detections, ensuring they include the deployment locations
xmin <- if_else(min(dup.df$recvLon, na.rm = TRUE) < min(dup.depl$tagDepLon, na.rm = TRUE), min(dup.df$recvLon, na.rm = TRUE) - 2, min(dup.depl$tagDepLon, na.rm = TRUE) - 2)
xmax <- if_else(max(dup.df$recvLon, na.rm = TRUE) > max(dup.depl$tagDepLon, na.rm = TRUE), max(dup.df$recvLon, na.rm = TRUE) + 2, max(dup.depl$tagDepLon, na.rm = TRUE) + 2)
ymin <- if_else(min(dup.df$recvLat, na.rm = TRUE) < min(dup.depl$tagDepLat, na.rm = TRUE), min(dup.df$recvLat, na.rm = TRUE) - 2, min(dup.depl$tagDepLat, na.rm = TRUE) - 2)
ymax <- if_else(max(dup.df$recvLat, na.rm = TRUE) > max(dup.depl$tagDepLat, na.rm = TRUE), max(dup.df$recvLat, na.rm = TRUE) + 2, max(dup.depl$tagDepLat, na.rm = TRUE) + 2)
                
out.map <- ggplot(na.lakes, aes(long, lat))+ 
  geom_polygon(data = na.map, aes(long, lat, group=group), colour = "grey", fill="grey98")+#
  geom_polygon(aes(group = group), colour = "grey", fill = "white")+
  coord_map(projection="mercator", xlim = c(xmin, xmax), ylim = c(ymin, ymax))+
  xlab("") + ylab("") + ggtitle(paste("ambigID: ", ambig.list[i], sep = ""))+
  theme_bw() + 
  geom_point(data = dup.df, aes(recvLon,recvLat), cex = 0.8, colour = "black", pch = 4)+
  geom_point(data = dup.depl, aes(tagDepLon,tagDepLat, colour = as.factor(project.motusTagID)), pch = 1, size = 3)+
  scale_colour_discrete("Deployment Location (projectID.motusTagID)")

pdf(file = paste(out.dir, "AmbigMap", ambig.list[i], ".pdf", sep = ""), width = 7, height = 7)
  print(out.map)
  dev.off()
  
}
```

## Assigning or dropping ambiguities from your data

To summarize, we want to:

- drop all detections associated with ambigIDs -114, -134.
- keep all detections associated with ambigID -337, and assign to motusTagID 16011.
- keep all detections associated with ambigID -106, and assign to motusTagID 17357.
- keep detections associated with ambigID -177 at site "Fortescue".
- drop all detections that occurred in 2017 for ambigID -56. For 2016 detections, assign detections with lat > 45 and lon < -75 to motusTagID 22867; all detections with lat < 45 and dmy < 2016-11-01 to motusTagID 22867; assign all other detections to motusTagID 23316.

We create a function that we can use to do this filtering, so that we can apply the function each time we load the data. Eventually, we hope to have a method to automatically report the assignment of ambiguities back to the main Motus server; for now we do it manually. Recall that the SQLite .motus file is currently assigned to the R object 't', and that the negative ambigIDs are included in the motusTagID column of this database:

```{r filterFunction}

filterProj38Ambigs <- function(df) {
  
  # load .motus file
  file.name <- df     ## or replace with the full location of your 'project-XX.motus' data
  t <- dplyr::src_sqlite(file.name)

  # extract alltagswithambigs and alltags views 
  ambigs <- tbl(t, "alltagswithambigs")
  ambigs <- ambigs %>% collect() %>% as.data.frame()
  # I'm having issues with NA ambigIDs being dropped by filter, so I'm replacing those with 0s first
  ambigs <- mutate(ambigs, ambigID = replace(ambigID, is.na(ambigID), 0)) %>%
    filter(ambigID != -134, ambigID != -114, tagProjID == 38)
 
  # create time variables, filter out ambiguous detections that don't belong to our tags 
  filt.data <- mutate(ambigs, 
                      year = year(as_datetime(ambigs$ts, tz = "GMT")), 
                      date = as.Date(as_datetime(ambigs$ts, tz = "GMT")),
                      recvLat = if_else(is.na(gpsLat), recvDeployLat, gpsLat), 
                      recvLon = if_else(is.na(gpsLon), recvDeployLon, gpsLon),
                      # turn motusTagIDs into NA where the amnig detections aren't associated with the tag:
                      motusTagID = replace(motusTagID, (ambigID == -171 & site != "Fortescue"), -1),
                      motusTagID = replace(motusTagID, (ambigID == -56 & year == 2017), -1),
                      motusTagID = replace(motusTagID, (ambigID == -56 & motusTagID == 22867 & recvLon > -72.5), -1),
                      motusTagID = replace(motusTagID, (ambigID == -56 & motusTagID == 23316 & recvLon < -72.5), -1)) %>%
                filter(motusTagID > 0) # drop all remainging ambigID -56 detections from 2017
                      
  return(filt.data)
}

```

We can then apply the filtering function to the data by calling:

```{r filterData, eval = FALSE}

ambigFilter <- filterProj38Ambigs(df = system.file("extdata", "project-sample.motus", package = "motusdata"))
                                
```

