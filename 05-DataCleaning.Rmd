# Data Cleaning {#dataCleaning}

Due to the nature of radio transmissions, false positive detections of your tags will occur. False positive detections result from radio noise or from duplicate tags transmitting in the network at the same time, where duplicate tags have the same Lotek ID code, burst interval, and nominal transmit frequency, resulting in 'ambiguous' detections that may belong to either tag. 

Key things to look for to determine if detections are false positive include:

1) Run length: run length ('runLen') is the number of tag bursts in a run, and a run is a group of consecutive detections of a tag detected on a receiver. In general, a detection with a run length of 2 has a high probability of being a false positive detection. With the exception of a few 'quiet' stations with little noise, we generally recommend that you filter out all detections with a run length of 2. However, because you may lose some true detections in the process, we also recommend examining which detections this would remove. 

2) Standard deviation of frequency offset: Standard deviation of frequency offset among pulses in a burst ('freqsd'; in KHz) can also be used as a coarse and automatic data filter, by removing any values larger that 0.1, which suggests a false detection. This filter applies to data collected by SensorGnome receivers only. As with run length, it is recommended that you identify the detections you would be removing and examine them to ensure you aren't removing an unwanted amounts of true detections.  

3) detections in regions or at times of year that don't make biological sense for the study species.

4) consecutive detections at distant sites that would require biologically unreasonable flight speeds to be true.  

The *goal of this chapter* is to provide you with the tools you need to check your data for false positive detections, and create a filter to remove them from your data. We do so using the following steps: 

1) Run preliminary data checks to see how many deployed tags have detections, the spatial distribution of tag deployments and detections, and to determine whether ambiguous detections are present in your data.

2) Create a custom data filter that is associated with your Motus login credentials.

3) Examine plots of tag paths, and populate the filter with detections determined to be false positive; filters those detections from the data.

4) Examine plots of latitude and longitude of detections against time, and populate the filter with detections determined to be false positive; filters those detections from the data.

5) Examine flight speed and bearing between detections, and populate the filter with detections determined to be false positive (based on unrealistic flight speeds); filter those detections from the data.

## Load required packages

Follow the instructions in Chapter \@ref(loadingPackages) to install the following packages before loading, if they are not already installed.

```{r loadpackages.5, message = FALSE, warning = FALSE}

library(devtools)
library(motus)
library(tidyverse)
library(lubridate)
library(rworldmap) # for mapping

```

## Load detections data

Recall from \@ref(accessingData) that when accessing the sample database, you will need to input "motus.sample" in the R console as both username and password when prompted by the tagme() user authentication process, this section assumes you have already completed the initial sample data download. 

When accessing the alltags table, we remove some variables that we do not currently need. We also create receiver latitude and longitude variables that are based on the coordinates recorded by the receiver GPS, and where those are not available, infilled with coordinates from the receiver deployment metadata. We use the collect() and as.data.frame() statements to transform the dataframe into a 'flat' file, and then transform all time stamp variables from seconds since January 1 1970 to datetime (POSIXct) format.

```{r importData5}

proj.num <- 176

# load detection data, select variables, create latitude variables, and transform to flat file
sql.motus <- tagme(proj.num, update = FALSE, dir = "./data/")
tbl.alltags <- tbl(sql.motus, "alltags")
df.alltags <- tbl.alltags %>%
                mutate(recvLat = if_else((is.na(gpsLat)|gpsLat == 0), recvDeployLat, gpsLat),
                       recvLon = if_else((is.na(gpsLon)|gpsLon == 0), recvDeployLon, gpsLon),
                       recvAlt = if_else(is.na(gpsAlt), recvDeployAlt, gpsAlt)) %>%
                select(-noise, -slop, -burstSlop, -done, -bootnum, -mfgID, -codeSet, -mfg, -nomFreq, -markerNumber, -markerType, -tagDeployComments, -fullID, -deviceID, -recvDeployLat, -recvDeployLon, -recvDeployAlt, -speciesGroup, -gpsLat, -gpsLon, - recvAlt, - recvSiteName) %>%
                collect() %>%
                as.data.frame() %>%
                mutate(ts = as_datetime(ts),  # work with dates AFTER transforming to flat file
                       tagDeployStart = as_datetime(tagDeployStart),
                       tagDeployEnd = as_datetime(tagDeployEnd)) 

```

## Preliminary data checks

Prior to filtering the data, we do a few summaries and plots of the data.

**1.  Check number of tags with detections**

First, how many project tags have detections. Apart from the tag not being within range of a receiver station, there are several reasons why deployed tags might not be detected, including:

1) the tag was not properly activated on deployment. To avoid this, always check that a tag is active using a hand-held receiver before attaching the tag to your study animal and releasing it. 

2) an animal with a properly activated tag might not pass within range of a receiving station. Study designs that incorporate strategic placement of receivers to meet project goals can improve your odds of getting detections of your tags.

3) missing or incorrect tag deployment metadata can result in the tagFinder not 'looking' for your tag at the time the tag was deployed, or at all. Please ensure your tag metadata are entered correctly.

Using the following code, we see there are detections for 18 tags deployed by the sample project:

```{r ntagsDetections}

df.alltags %>%
  filter(tagProjID == proj.num) %>% # subset to include only tags registered to project
  select(motusTagID) %>%
  distinct() %>%
  summarize(nTags = n()) # if you want to see the list of motusTagIDs, replace summarize(nTags =n()) with as.list()

```

**2. Check number of tags with ambiguous detections**

The clarify() function in the motusClient R package provides a summary of ambiguities in the detections data. Each ambigID refers to a selection of detections that could belong to one or more (up to 6) motusTagIDs, which are listed in the id1 to id6 fields:

```{r checkForAmbigs}

df.clarify <- clarify(sql.motus)
df.clarify

```

Note that detections associated with five of the six ambigIDs could belong to one of two tags, and detections associated with one ambigID (-171) could belong to one of three tags. The fullID fields list the project names associated with the duplicate tags (e.g., "SampleData", "Selva", "Niles", etc.), along with features of the tags (manufacturer tag ID, burst, and transmit frequency). 

**3. Subset to a sample of tags**

For the purpose of this chapter, we simplify the sample data by subsetting to six motusTagIDs:  four tags (motusTagID = 22897, 22905, 23319, 22902) were attached to Red Knots and are associated with ambiguous detections (ambigID = -114, -134, -171 respectively), and two tags (16038, 16047) were attached to a Semipalmated Sandpiper and Red Knot, respectively, and are not associated with ambiguous detections.

```{r subsetTags}

# generate list of tags to keep
tag.list <- as.data.frame(c(22897, 22905, 23319, 22902, 16038, 16047)) 
names(tag.list) <- "motusTagID"

# generate list of motusTagIDs that includes the motusTagIDs of duplicate tags from other projects, i.e., associated with ambigIDs -114, -134, -171
ambigTag.list <- gather(select(df.clarify, ambigID, id1, id2, id3, id4, id5, id6), id, motusTagID, c(id1, id2, id3, id4, id5, id6), factor_key=TRUE) %>%
  filter(!is.na(motusTagID), ambigID %in% c(-114, -134, -171)) %>%
  select(motusTagID) %>%
  bind_rows(tag.list) %>%
  distinct()

## subset detections data to the tags of interest from our project (excluding detections of duplicate tags)
df.alltags.sub <- df.alltags %>%
                    filter(motusTagID %in% tag.list$motusTagID)

## subset deployment records to tags of interest AND duplicate tags.
tbl.tagDeps <- tbl(sql.motus, "tagDeps")
df.tagDeps.sub <- tbl.tagDeps %>%
                    filter(tagID %in% ambigTag.list$motusTagID) %>%
                    select(deployID, tagID, projectID, fullID, tsStart, tsEnd, speciesID, latitude, longitude) %>%
                    collect() %>%
                    as.data.frame() %>%
                    mutate(
                      tsStart = as_datetime(tsStart),
                      tsEnd = as_datetime(tsEnd))

```

**4. Plot tag paths, including ambiguous/false detections**

Plotting the paths of each tag will show us where project tags were deployed, where detections occurred, which detections are ambiguous, and which detections have a run length == 2.

First summarize and order the data by tag and time stamp, then calculate maximum run length by date and receiver (ignore time of day for the purpose or this plot): 

```{r plotTagPaths.5}

df.alltags.path <- df.alltags.sub %>%
                    filter(tagProjID == proj.num) %>% # keep to tags registered to the sample project
                    arrange(motusTagID, ts) %>%       # order data by time stamp for each motus tag ID
                    mutate(date = as_date(ts)) %>%    # create date variable
                    group_by(motusTagID, date, recvDeployName, ambigID, tagDeployLon, tagDeployLat, recvLat, recvLon)%>%
                    summarize(max.runLen = max(runLen)) 
                    
                    
```

Then load the base map files:

```{r loadMaps.5, message = FALSE, warning = FALSE}

na.lakes <- map_data(map = "lakes")
na.lakes <- mutate(na.lakes, long = long- 360)

## Include all of the Americas to begin
na.map <- subset(map_data(map="world2"), 
                 region %in% c("Canada", "USA", "Mexico", "lakes",
                               "Belize", "Costa Rica", "Panama", 
                               "Guatemala", "Honduras", "Nicaragua", 
                               "El Salvador", "Colombia", "Venezuela", "Ecuador", "Peru", "Brazil",
                               "Guyana","Suriname", "Bolivia", "French Guiana", "Jamaica", "Cuba", 
                               "Haiti", "Dominican Republic", "The Bahamas", "Turks and Caicos Islands", 
                               "Puerto Rico", "British Virgin Islands", "Montserrat", "Dominica", "Saint Lucia", 
                               "Barbados", "Grenada", "Trinidad and Tobago", "Chile", "Argentina", "Uruguay", "Paraguay"))

na.map <- mutate(na.map, long = long- 360)

```

Finally, to map the paths using ggplot, set the x-axis and y-axis limits based on the location of receivers with detections. Note that if the tags were not deployed near towers with detections, the axis limits might need to be modified to encompass the deployment location of the tags. 

```{r mapDetections1}

## set limits to map based on locations of detections, ensuring they include the deployment locations
xmin <- min(df.alltags.path$recvLon, na.rm = TRUE) - 2
xmax <- max(df.alltags.path$recvLon, na.rm = TRUE) + 2
ymin <- min(df.alltags.path$recvLat, na.rm = TRUE) - 2
ymax <- max(df.alltags.path$recvLat, na.rm = TRUE) + 2
                
## map
ggplot(na.lakes, aes(long, lat))+ 
  geom_polygon(data = na.map, aes(long, lat, group=group), colour = "grey", fill="grey98")+#
  geom_polygon(aes(group = group), colour = "grey", fill = "white")+
  coord_map(projection="mercator", xlim = c(xmin, xmax), ylim = c(ymin, ymax))+
  xlab("") + ylab("") + 
  theme_bw() + 
  geom_path(data = df.alltags.path, aes(recvLon, recvLat, group = motusTagID), colour = "grey20") + 
  geom_point(data = df.alltags.path, aes(recvLon, recvLat, colour = !is.na(ambigID), shape = (max.runLen > 2)), size =1.5)+
  geom_point(data = df.alltags.path, aes(tagDeployLon, tagDeployLat), colour = "black", shape = 4) +
  scale_colour_discrete("motusTagID") +
  scale_shape_manual(values = c(1, 2)) +
  scale_colour_manual(values = c("deepskyblue3", "darkorange1"))+
  facet_wrap(~motusTagID, nrow = 2)

```

**Figure 5.1.** Plot of the paths of several tags, showing whether detections were ambiguous (orange) or not (blue), and whether a detection had a run length of 2 (circle; implies a high probability of being false positive) or greater than 2 (triangle; higher probability of being a true detection). Tag deployment location is shown by a black 'x'. From the plot of tag paths, we can see that some of the ambiguous detections likely belong to other tags (e.g. tag 22897), and some non-ambiguous detections could be false positives. 

## Filter the data

To filter the data, you can use the Motus R package functionalities to create a custom data filter (see \@ref(#appendixC)) that is attached to your user profile (motus login credentials), and can be used to 1) assign probabilities to detections, and 2) filter detections based on those probabilities each time you load your .motus file. The filter is created, populated, and applied in the following steps:

1. use the 'createRunsFilter' function to create (but not populate) a filter named 'filtAmbigFalsePos'.  
2. Generate a dataframe which includes the motusTagID and runID of detections you want to filter.  
3. Assign a probability to those detections. In this chapter we assign a probability of 0 to detections we deem are false positive.  
4. Use the 'writeRunsFilter' function to populate the filter. Using the delete = TRUE option will remove all records previously written to the filter; using the overwrite = FALSE option will allow new records to be appended to the filter.  
5. Use the 'applyRunsFilter' function to assign the probabilities to the records in your .motus file. Note that this function simply assigns each run of detections in the database with the probability, unless the 'p.min =' statement is used, which drops all detections with a probability <= p.min.  

### Create a custom data filter for your .motus file

```{r createFilter, eval = FALSE}

createRunsFilter(sql.motus, 
                 filterName = "filtAmbigFalsePos", 
                 motusProjID = 176, 
                 descr = "filter to assign probability = 0 to false positive detections and ambiguities that belong to other tags (Chapter 5 in R Book)")

```

Check that the filter was created using the 'listRunsFilters' function; note that the filter has been assigned a unique filterID of 1:

```{r listRunsFilters.5}

listRunsFilters(sql.motus)

```

### Filter detections with run length = 2 and standard deviation of frequency offset >= 0.1

For demonstration, re-plot the data including only detections with runLen > 2 and freqsd < 0.1:

```{r mapDetections2}

df.alltags.path <- df.alltags.sub %>%
                    filter(tagProjID == proj.num, runLen > 2, freqsd < 0.1) %>% # keep to tags registered to the sample project
                    arrange(motusTagID, ts) %>%       # order data by time stamp for each motus tag ID
                    mutate(date = as_date(ts)) %>%    # create date variable
                    group_by(motusTagID, date, recvDeployName, ambigID, tagDeployLon, tagDeployLat, recvLat, recvLon)%>%
                    summarize(max.runLen = max(runLen)) 

## set limits to map based on locations of detections, ensuring they include the deployment locations
xmin <- min(df.alltags.path$recvLon, na.rm = TRUE) - 2
xmax <- max(df.alltags.path$recvLon, na.rm = TRUE) + 2
ymin <- min(df.alltags.path$recvLat, na.rm = TRUE) - 2
ymax <- max(df.alltags.path$recvLat, na.rm = TRUE) + 2
                
## map
ggplot(na.lakes, aes(long, lat))+ 
  geom_polygon(data = na.map, aes(long, lat, group=group), colour = "grey", fill="grey98")+#
  geom_polygon(aes(group = group), colour = "grey", fill = "white")+
  coord_map(projection="mercator", xlim = c(xmin, xmax), ylim = c(ymin, ymax))+
  xlab("") + ylab("") + 
  theme_bw() + 
  geom_path(data = df.alltags.path, aes(recvLon, recvLat, group = motusTagID), colour = "grey20") + 
  geom_point(data = df.alltags.path, aes(recvLon, recvLat, colour = !is.na(ambigID)), size =1.5)+
  geom_point(data = df.alltags.path, aes(tagDeployLon, tagDeployLat), colour = "black", shape = 4) +
  scale_colour_discrete("motusTagID") +
  #scale_shape_manual(values = c(1, 2)) +
  scale_colour_manual(values = c("deepskyblue3", "darkorange1"))+
  facet_wrap(~motusTagID, nrow = 2)

```

**Figure 5.2**. Plot of the paths of several tags, showing whether detections were ambiguous (orange) or not (blue), for detections with a run length greater than two and standard deviation of frequency offset > 0.1. Tag deployment location is shown by a black 'x'. We note that the paths are much cleaner than in Figure 5.1.

Next, generate a dataframe 'df.tagRuns' that includes the motusTagID and runID of detections we decide do not belong to our tags. In this case, we select all detections with runLen = 2 and/or a standard deviation of frequency offset >= 0.1 (remember that frequency offset only applies to SensorGnome receivers). We also assign a probability of 0 to the records:

```{r filterRunLen}

df.tagRuns <- df.alltags.sub %>%
  filter(freqsd > 0.1|runLen == 2) %>%
  select(motusTagID, runID) %>%
  mutate(probability = 0) %>%
  distinct()

```

Then populate the 'filtAmbigFalsePos' filter using the `writeRunsFilter` function. To remove previously written detections from the filter, use the delete = TRUE option (not done here):

```{r writeFilter1}

writeRunsFilter(sql.motus, "filtAmbigFalsePos", motusProjID = 176, df = df.tagRuns)

```
Check that the records were applied to the filter using the 'getRunsFilters' function:

```{r getRunsFilter1}

df.check <- getRunsFilters(sql.motus, "filtAmbigFalsePos")
head(df.check)

```

Finally, apply the filter to the .motus file. We filter the data by those probabilities by assigning a p.min = 0.1, which drops all detections associated with a probability < 0.1.

Note also that because the filter is applied to the .motus file and not our flat file, we need to re-create the flat file. Going forward, once the filter is completely populated, you will only need to do this when you first import your .motus file. Here, we start from tagme() to show you how the filter would be applied when you first import your data:

```{r overwriteFilter1, eval = FALSE}

# load the .motus file
sql.motus <- tagme(176, update = FALSE, dir = "./data/")
```
```{r overwriteFilter2}
# apply the filter; a dataframe is output
df.alltags.filt <- applyRunsFilter(sql.motus, "filtAmbigFalsePos", p.min = 0.1)

# manage the dataframe
df.alltags.filt <- df.alltags.filt %>%
                      filter(motusTagID %in% tag.list$motusTagID) %>%
                      mutate(recvLat = if_else((is.na(gpsLat)|gpsLat == 0), recvDeployLat, gpsLat),
                             recvLon = if_else((is.na(gpsLon)|gpsLon == 0), recvDeployLon, gpsLon),
                             recvAlt = if_else(is.na(gpsAlt), recvDeployAlt, gpsAlt),
                             ts = as_datetime(ts),  # work with dates AFTER transforming to flat file
                             tagDeployStart = as_datetime(tagDeployStart),
                             tagDeployEnd = as_datetime(tagDeployEnd)) %>%
                      select(-noise, -slop, -burstSlop, -done, -bootnum, -mfgID, -codeSet, -mfg, -nomFreq, -markerNumber, -markerType, -tagDeployComments, -fullID, -deviceID, -recvDeployLat, -recvDeployLon, -recvDeployAlt, -speciesGroup, -gpsLat, -gpsLon, - recvAlt, - recvSiteName) %>%
                      collect() %>%
                      as.data.frame() %>%
                      mutate() 

```

### Examine plots of tag paths

Re-plot the tag paths using the filtered data:

```{r mapDetections3}

df.alltags.path <- df.alltags.filt %>%
                    filter(tagProjID == proj.num) %>% # keep to tags registered to the sample project
                    arrange(motusTagID, ts) %>%       # order data by time stamp for each motus tag ID
                    mutate(date = as_date(ts)) %>%    # create date variable
                    group_by(motusTagID, date, recvDeployName, ambigID, tagDeployLon, tagDeployLat, recvLat, recvLon)%>%
                    summarize(max.runLen = max(runLen)) 

## set limits to map based on locations of detections, ensuring they include the deployment locations
xmin <- min(df.alltags.path$recvLon, na.rm = TRUE) - 2
xmax <- max(df.alltags.path$recvLon, na.rm = TRUE) + 2
ymin <- min(df.alltags.path$recvLat, na.rm = TRUE) - 2
ymax <- max(df.alltags.path$recvLat, na.rm = TRUE) + 2
                
## map
ggplot(na.lakes, aes(long, lat))+ 
  geom_polygon(data = na.map, aes(long, lat, group=group), colour = "grey", fill="grey98")+#
  geom_polygon(aes(group = group), colour = "grey", fill = "white")+
  coord_map(projection="mercator", xlim = c(xmin, xmax), ylim = c(ymin, ymax))+
  xlab("") + ylab("") + 
  theme_bw() + 
  geom_path(data = df.alltags.path, aes(recvLon, recvLat, group = motusTagID), colour = "grey20") + 
  geom_point(data = df.alltags.path, aes(recvLon, recvLat, colour = !is.na(ambigID)), size =1.5)+
  geom_point(data = df.alltags.path, aes(tagDeployLon, tagDeployLat), colour = "black", shape = 4) +
  scale_colour_discrete("motusTagID") +
  #scale_shape_manual(values = c(1, 2)) +
  scale_colour_manual(values = c("deepskyblue3", "darkorange1"))+
  facet_wrap(~motusTagID, nrow = 2)

```

From these plots, we can safely drop some ambiguous detections that belong to duplicate tags from other projects:

**motusTagID 16038:** 

From this plot, there are no obvious false positive detections for this tag.

**motusTagID 16047:** 

Again for this tag, there are no obvious false positive detections. The path follows an expected trajectory for a Red Knot departing on fall migration from the James Bay area.

**motusTagID 22897:**

- using 'clarify(sql.motus)', the ambiguous detections in the Great Lakes region could also belong to tag 24298 released by the Neonics project. Filtering the tag deployment metadata using 'filter(df.tagDeps.sub, tagID == 24298)', we see that that duplicate tag was released on the north shore of Lake Erie. Those ambiguities most likely belong to that tag, and can be dropped from our data.


```{r filter1Tag3}

df.tagRuns <- filter(df.alltags.filt, 
                     motusTagID == 22897, 
                     (!is.na(ambigID))) %>%
                  select(motusTagID, runID) %>%
                  distinct() %>%
                  bind_rows(df.tagRuns)

```

**motusTagID 22902:** 

- using 'clarify(sql.motus)', the ambiguous detections for this tag, which occur in the great lakes region, could also belong to motusTagID 22778 from the RBrownAMWO project or motusTagID 24303 from the Neonics project. The Neonics project deployed tags on the north shore of Lake Erie in Ontario, Canada, so ambiguous detections in that region can be safely removed from the sample data.

```{r filter1Tag4}

df.tagRuns <- filter(df.alltags.filt, 
                     motusTagID == 22902, 
                     (!is.na(ambigID))) %>%
                  select(motusTagID, runID) %>%
                  distinct() %>%
                  bind_rows(df.tagRuns)

```

**motusTagID 22905:**

- using 'filter(df.tagDeps.sub, tagID == 22905|tagID == 23319)', we see that this tag and tag 23319 were deployed by the James Bay Shorebird Project (Sample Project) within two weeks of each other, and from the same deployment location. As a result, most detections are ambiguous and cannot be assigned with confidence to either tag. All ambiguous detections will unfortunately be dropped for this tag and for tag 23319. Only non-ambiguous detections of tag 22905 between October 10 2016 when it was deployed, and October 15 2016 when tag 23319 were deployed, will be useful for looking at movement behaviour. 


```{r filter1Tag5}

df.tagRuns <- filter(df.alltags.filt, 
                     motusTagID == 22905, 
                     (!is.na(ambigID))) %>%
                  select(motusTagID, runID) %>%
                  distinct() %>%
                  bind_rows(df.tagRuns)

```

**motusTagID 23319:**

- as stated above for tag 22905, all ambiguous detections will be dropped for this tag, because they can't be assigned with confidence to either tag.

```{r filter1Tag6}

df.tagRuns <- filter(df.alltags.filt, 
                     motusTagID == 23319, 
                     (!is.na(ambigID))) %>%
                  select(motusTagID, runID) %>%
                  distinct() %>%
                  mutate(probability = 0) %>%
                  bind_rows(df.tagRuns)

```

Re-populate the 'filtAmbigFalsePos' filter with the 'df.tagRuns' list using the `writeRunsFilter` function. In this case, because we appended new runIDs to 'df.tagRuns' created previously, delete the existing records in the filter:

```{r writeFilter2}

writeRunsFilter(sql.motus, "filtAmbigFalsePos", motusProjID = 176, df = df.tagRuns, delete = TRUE)

```

To append new records to the filter, leaving previous records intact, use the overwrite = FALSE statement (not evaluated here):

```{r overwriteFilter3, eval = FALSE}

writeRunsFilter(sql.motus, "filtAmbigFalsePos", df = df.tagRuns, overwrite = FALSE)

```

Again, check that records were applied to the filter using the 'getRunsFilters' function:

```{r getRunsFilter2}

df.check <- getRunsFilters(sql.motus, "filtAmbigFalsePos")
head(df.check)

```

Again, apply the filter to the .motus file, and re-format the data into a flat file before continuing to the next step. Note that this code is *exactly* the same as in the previous section, the only difference is that the 'filtAmbigFalsePos' filter now contains more runIDs to filter out of the data:

```{r overwriteFilter4}

# load the .motus file
sql.motus <- tagme(176, update = TRUE, dir = "./data/")

# apply the filter; a dataframe is output
df.alltags.filt <- applyRunsFilter(sql.motus, "filtAmbigFalsePos", p.min = 0.1)

# manage the dataframe
df.alltags.filt <- df.alltags.filt %>%
                      filter(motusTagID %in% tag.list$motusTagID) %>%
                      mutate(recvLat = if_else((is.na(gpsLat)|gpsLat == 0), recvDeployLat, gpsLat),
                             recvLon = if_else((is.na(gpsLon)|gpsLon == 0), recvDeployLon, gpsLon),
                             recvAlt = if_else(is.na(gpsAlt), recvDeployAlt, gpsAlt),
                             ts = as_datetime(ts),  # work with dates AFTER transforming to flat file
                             tagDeployStart = as_datetime(tagDeployStart),
                             tagDeployEnd = as_datetime(tagDeployEnd)) %>%
                      select(-noise, -slop, -burstSlop, -done, -bootnum, -mfgID, -codeSet, -mfg, -nomFreq, -markerNumber, -markerType, -tagDeployComments, -fullID, -deviceID, -recvDeployLat, -recvDeployLon, -recvDeployAlt, -speciesGroup, -gpsLat, -gpsLon, - recvAlt, - recvSiteName) %>%
                      collect() %>%
                      as.data.frame() %>%
                      mutate() 

```

Re-run the plot of tag paths to see that the paths are again much cleaner:

```{r plotPaths2, message = FALSE, warning = FALSE}

df.alltags.path <- df.alltags.filt %>%
                    filter(tagProjID == proj.num) %>% # keep to tags registered to the sample project
                    arrange(motusTagID, ts) %>%       # order data by time stamp for each motus tag ID
                    mutate(date = as_date(ts)) %>%    # create date variable
                    group_by(motusTagID, date, recvDeployName, ambigID, tagDeployLon, tagDeployLat, recvLat, recvLon)%>%
                    summarize(max.runLen = max(runLen)) 
## map
## set limits to map based on locations of detections, ensuring they include the deployment locations
xmin <- min(df.alltags.path$recvLon, na.rm = TRUE) - 2
xmax <- max(df.alltags.path$recvLon, na.rm = TRUE) + 2
ymin <- min(df.alltags.path$recvLat, na.rm = TRUE) - 2
ymax <- max(df.alltags.path$recvLat, na.rm = TRUE) + 2

ggplot(na.lakes, aes(long, lat))+ 
  geom_polygon(data = na.map, aes(long, lat, group=group), colour = "grey", fill="grey98")+#
  geom_polygon(aes(group = group), colour = "grey", fill = "white")+
  coord_map(projection="mercator", xlim = c(xmin, xmax), ylim = c(ymin, ymax))+
  xlab("") + ylab("") + 
  theme_bw() + 
  geom_path(data = df.alltags.path, aes(recvLon, recvLat, group = motusTagID), colour = "grey20") + 
  geom_point(data = df.alltags.path, aes(recvLon, recvLat, colour = !is.na(ambigID), shape = (max.runLen > 2)), size =1.5)+
  geom_point(data = df.alltags.path, aes(tagDeployLon, tagDeployLat), colour = "black", shape = 4) +
  scale_colour_discrete("motusTagID") +
  scale_shape_manual(values = c(1, 2)) +
  scale_colour_manual(values = c("deepskyblue3", "darkorange1"))+
  facet_wrap(~motusTagID, nrow = 2)

```

## Filter data based on geographic position (latitude/longitude) against time

Next, visualize the time and location of detections relative to the time and location of tag deployments. When we plot the data, we want to include the deployment date and location of any duplicate tag, so we can visualize where detections fall relative to the tag deployments. Because we are plotting with a facet based on motusTagID, and not ambigID, we need to first manipulate the data, so that we end up with a deployment metadata table that has a 'tagID' variable which tells us which 'motusTagID' the deployment information belongs to, and a 'motusTagID' field which tells us which of our tags this deployment information should be plotted with (i.e., which tag it is a duplicate of).  

Note that if you have a large number of tags (say > 6) in your data, these plots will be messy, and you will want to plot each tag individually or in subsets of tags. 

```{r importTagMeta}

## get a list of the motusIDs for all of ambiguous IDs
df.allambigs <-  tbl(sql.motus, "allambigs") %>%
  collect() %>% 
  as.data.frame() 

df.myAmbigs <- df.allambigs %>%
  filter(motusTagID %in% tag.list$motusTagID)

## deployments in this table are the deployments of the duplicate tags (motusTagDup)
df.myDeps <- left_join(df.tagDeps.sub,
                          df.allambigs,
                          by = c("tagID" = "motusTagID"))

## merge again, creating a new variable with both the projectID
## and the MotusTagID which makes it easier for plotting to see where
## the various ambiguous come from.

df.myDeps <- left_join(df.myDeps, df.myAmbigs, by = "ambigID") %>%
  mutate(plot.id = paste(ambigID, tagID, projectID, sep = "."),
         motusTagID = if_else(is.na(motusTagID), tagID, motusTagID))

```

**Plot latitude of detections against time.**

```{r plotLatbyTime, fig.width=11, fig.height=6}

ggplot(data = filter(df.alltags.filt, is.na(ambigID)), # plot ambiguous detections first
            aes(ts, recvLat)) +
  geom_point(size = 1, shape = 1) +
  geom_point(data = filter(df.alltags.filt, !is.na(ambigID)), aes(ts, recvLat), size = 1, shape = 2) + # add non-ambiguous detections
  geom_point(data = df.myDeps, aes(tsStart, latitude, colour = plot.id), size = 2, shape = 13) +
  facet_wrap(~ motusTagID, ncol= 3, scales = "free") + 
  theme_bw() +   
  ylab("Latitude") + xlab("Date") +
  guides(colour=guide_legend(title="id.motusTagID.projectID")) 

```
**Plot longitude of detections against time.**

```{r plotLonbyTime}

ggplot(data = filter(df.alltags.filt, is.na(ambigID)), # plot ambiguous detections first
            aes(ts, recvLon)) +
  geom_point(size = 1, shape = 1) +
  geom_point(data = filter(df.alltags.filt, !is.na(ambigID)), aes(ts, recvLon), size = 1, shape = 2) + # add non-ambiguous detections
  geom_point(data = df.myDeps, aes(tsStart, longitude, colour = plot.id), size = 2, shape = 13) +
  facet_wrap(~ motusTagID, ncol= 3, scales = "free") + 
  theme_bw() +   
  ylab("Longitude") + xlab("Date") +
  guides(colour=guide_legend(title="id.motusTagID.projectID")) 

```

**motusTagID 16038**

- there are detections at two towers, not far apart. From these plots, there don't appear to be additional false positives for this tag.

**motusTagID 16047**

- there is nothing that stands out about these detections that requires filtering in this step; you can see that after this Red Knot departed the James Bay region, it was detected moving south along the east coast at an appropriate time of year and in an appropriate location.

**motusTagID 22897**

- using 'filter(df.alltags.filt, motusTagID == 22897, recvLon < -80)', we see that the detections in the Great Lakes region (recvDeployName "Old Cut") occurred on April 20, 2017 at 22:33 (HH:MM). The detections have a run length of 3 or 4, freqsd is < 0.1, and detections were recorded by three of four antennas at the Old Cut station. Normally Red Knots migrate through that region in May, so this is potentially a little bit early to detect Red Knots at this tower, but not impossible. 

**motusTagID 22902**

- the only detections for this tag occur at the deployment location, near the deployment time, so these are true detections of the tag.

**5. motusTagID 22905**

- I can't finish this and the next tag until the filter is working properly

**motusTagID 23319**

## Filter data based on flight speed between detections {#filterFlightSpeed}

By looking at the rate of movement between sites with consecutive detections, we can often quickly view flights that are not physically possible. At this point, our data is looking pretty clean, but we want to be thorough.

Rate of movement between sites can be determined using the siteTrans function in the motus R package (see \@ref(#appendixB). The output is in m for distance, and m/s for rate. 

```{r falseBySpeed1, message = FALSE, warning = FALSE}

# REMOVE THE FOLLOWING LINE WHEN FILTER WORKING PROPERLY
df.alltags.filt <- filter(df.alltags.filt, is.na(ambigID))

df.detectTrans <- as.data.frame(siteTrans(df.alltags.filt, latCoord = "recvLat", lonCoord = "recvLon")) ## create new data.base consisting of transitions between consecutive sites for each tag
head(df.detectTrans)
summary(df.detectTrans)

```

There are a few transitions with unusually high speeds. We subset those out to take a closer look:

```{r falseBySpeed2}

filter(df.detectTrans, rate > 60)

df.detectTrans %>%
  group_by(motusTagID) %>%
  summarize()
```

All of the high rates are for one tag, 16047, attached to a Red Knot, and appear to be the result of simultaneous detections by the BennetMeadow and Shelbourne sites, which are within 20km of each other north of Amherst Massachusetts, and 7 hours later by the the BISE and TRUS stations, which are within 30 km of each other on the east coast near Rhode Island. These are not false positive detections, rather, this method of estimating distance and speed is inappropriate in this circumstance, because the bird is most likely migrating somewhere between the two stations.

