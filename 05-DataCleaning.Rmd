# Data Cleaning {#dataCleaning}

Due to the nature of radio transmissions, automated radio-telemetry data can often result in false positive detections of your tags due to radio noise or duplicate tags. Some sites will inherently have more background noise than others, and some tag IDs are more prone to false positives than others. Further, when two or more duplicate tags with the same Lotek ID code, burst interval, and nominal transmit frequency (i.e., the transmissions of tags are indistinguishable) are transmitting in the network at the same time, detections can be 'ambiguous', i.e., may belong to either tag. 

The goal of this chapter is to provide you with the tools you need to clean false positive detections from your data. We do so using the following steps: 

1) Run preliminary data checks to see how many deployed tags have detections, the spatial distribution of tag deployments and detections, and to determine whether ambiguous detections are present in your data.

2) Create a custom data filter using the functions provided in the motusClient package.

3) Examine plots of tag paths, and append detections determined to be false positive to the filter; filter those detections from the data.

4) Examine plots of latitude and longitude of detections against time, and append detections determined to be false positive to the filter; filters those detections from the data.

5) Examine flight speed and bearing between detections, and append detections determined to be false positive (based on unrealistic flight speeds) to the filter; filter those detections from the data.

6) Using filter 


## Load required packages

Follow the instructions in Chapter \@ref(loadingPackages) to install the following packages before loading, if you haven't already done so.

```{r loadpackages, message = FALSE, warning = FALSE}

library(devtools)
library(motus)
library(tidyverse)
library(lubridate)
library(rworldmap) # for mapping

```

## Load detections data

Recall from \@ref(accessingData) that when accessing the sample database, you will need to input "motus.sample" as both username and password when prompted by the tagme() user authentication process. 

When accessing the alltags table, we remove some variables that we do not currently need, and create receiver latitude and longitude variables that are based on the coordinates recorded by the receiver GPS, and where those are not available, infilled with coordinates from the receiver deployment metadata. Once in a flat file format (after the collect() and as.data.frame() statements), we transform any time stamp variables from seconds since January 1 1970 to datetime (POSIXct) format.

```{r importData5}

proj.num <- 176

# load detection data, select variables, create latitude variables, and transform to flat file
sql.motus <- tagme(proj.num, update = TRUE, dir = "./data/")
tbl.alltags <- tbl(sql.motus, "alltags")
df.alltags <- tbl.alltags %>%
                mutate(recvLat = if_else((is.na(gpsLat)|gpsLat == 0), recvDeployLat, gpsLat),
                       recvLon = if_else((is.na(gpsLon)|gpsLon == 0), recvDeployLon, gpsLon),
                       recvAlt = if_else(is.na(gpsAlt), recvDeployAlt, gpsAlt)) %>%
                select(-noise, -slop, -burstSlop, -done, -bootnum, -mfgID, -codeSet, -mfg, -nomFreq, -markerNumber, -markerType, -tagDeployComments, -fullID, -deviceID, -recvDeployLat, -recvDeployLon, -recvDeployAlt, -speciesGroup, -gpsLat, -gpsLon, - recvAlt, - recvSiteName) %>%
                collect() %>%
                as.data.frame() %>%
                mutate(ts = as_datetime(ts),  # work with dates AFTER transforming to flat file
                       tagDeployStart = as_datetime(tagDeployStart),
                       tagDeployEnd = as_datetime(tagDeployEnd)) 

```

## Preliminary data checks

Prior to filtering the data, we want to examine what the data look like.

**1.  Check number of tags with detections**

First, check how many project tags have detections. There are several reasons why deployed tags might not have detections, including:

1) the tag was not properly activated on deployment. To avoid this, always check that a tag is active using a hand-held receiver before attaching the tag to your study animal and releasing it. 

2) an animal with a properly activated tag might not pass within range of a receiving station. Study designs that incorporate strategic placement of receivers to meet project goals can improve your odds of getting detections of your tags.

3) missing or incorrect tag deployment metadata can result in the tagFinder not 'looking' for your tag at the time the tag was deployed, or at all. 

Using the following code, we see there are detections for 18 tags deployed by the sample project:

```{r ntagsDetections}

df.alltags %>%
  filter(tagProjID == proj.num) %>% # subset to include only tags registered to project
  select(motusTagID) %>%
  distinct() %>%
  summarize(nTags = n()) # if you want to see the list of motusTagIDs, replace summarize(nTags =n()) with as.list()

```

**2. Check number of tags with ambiguous detections**

The clarify() function in the motusClient R package provides a summary of ambiguities in the detections data. Each ambigID refers to a selection of detections that could belong to one or more (up to 6) motusTagIDs, which are listed in the id1 to id6 fields:

```{r checkForAmbigs}

df.clarify <- clarify(sql.motus)
df.clarify

```

Note that detections associated with five of the six ambigIDs could belong to one of two tags, and detections associated with one ambigID (-171) could belong to one of three tags. The fullID fields list the project names associated with the duplicate tags (e.g., "SampleData", "Selva", "Niles", etc.), along with features of the tags (manufacturer tag ID, burst, and transmitting frequency). 

**3. Subset to a sample of tags**

For the purpose of this chapter, we simplify the sample dataframes by subsetting to six motusTagIDs:  four tags (motusTagID = 22897, 22905, 23319, 22902) were attached to Red Knots and are associated with ambiguous detections (ambigID = -114, -134, -171 respectively), and two tags (16038, 16047) were attached to a Semipalmated Sandpiper and Red Knot, respectively, and are not associated with ambiguous detections.

# ZOE, if you have a suggestion to replace one or two of these with a more interesting movement, please do so, or let me know!

```{r subsetTags}

tag.list <- as.data.frame(c(22897, 22905, 23319, 22902, 16038, 16047)) # list of tags we are keeping
names(tag.list) <- "motusTagID"

# generate list of motusTagIDs that includes tags from other projects associated with the ambigIDs in our subsample of tags
ambigTag.list <- gather(select(df.clarify, ambigID, id1, id2, id3, id4, id5, id6), id, motusTagID, c(id1, id2, id3, id4, id5, id6), factor_key=TRUE) %>%
  filter(!is.na(motusTagID), ambigID %in% c(-114, -134, -171)) %>%
  select(motusTagID) %>%
  bind_rows(tag.list) %>%
  distinct()

## subset detections data to the tags of interest from our project
df.alltags.sub <- df.alltags %>%
                    filter(motusTagID %in% tag.list$motusTagID)

## subset deployment records to tags of interest AND any duplicate tags.

tbl.tagDeps <- tbl(sql.motus, "tagDeps")
df.tagDeps.sub <- tbl.tagDeps %>%
                    filter(tagID %in% ambigTag.list$motusTagID) %>%
                    select(deployID, tagID, projectID, fullID, tsStart, tsEnd, speciesID, latitude, longitude) %>%
                    collect() %>%
                    as.data.frame() %>%
                    mutate(
                      tsStart = as_datetime(tsStart),
                      tsEnd = as_datetime(tsEnd))
                    
                    

```

**4. Plot tag paths, including ambiguous/false detections**

Plotting the paths of each tag will give us an idea of where detections occurred, and which of those detections are ambiguous.

To do so, first summarize and order the data by tag and time stamp, and calculate max run length by date (ignoring time of day for this purpose): 

```{r plotTagPaths}

df.alltags.path <- df.alltags.sub %>%
                    filter(tagProjID == proj.num) %>% # keep to tags registered to the sample project
                    arrange(motusTagID, ts) %>%       # order data by time stamp for each motus tag ID
                    mutate(date = as_date(ts)) %>%    # create date variable
                    group_by(motusTagID, date, recvDeployName, ambigID, tagDeployLon, tagDeployLat, recvLat, recvLon)%>%
                    summarize(max.runLen = max(runLen)) 
                    
                    
```


We then load the base map files:

```{r loadMaps, message = FALSE, warning = FALSE}

na.lakes <- map_data(map = "lakes")
na.lakes <- mutate(na.lakes, long = long- 360)

## Include all of the Americas to begin
na.map <- subset(map_data(map="world2"), 
                 region %in% c("Canada", "USA", "Mexico", "lakes",
                               "Belize", "Costa Rica", "Panama", 
                               "Guatemala", "Honduras", "Nicaragua", 
                               "El Salvador", "Colombia", "Venezuela", "Ecuador", "Peru", "Brazil",
                               "Guyana","Suriname", "Bolivia", "French Guiana", "Jamaica", "Cuba", 
                               "Haiti", "Dominican Republic", "The Bahamas", "Turks and Caicos Islands", 
                               "Puerto Rico", "British Virgin Islands", "Montserrat", "Dominica", "Saint Lucia", 
                               "Barbados", "Grenada", "Trinidad and Tobago", "Chile", "Argentina", "Uruguay", "Paraguay"))

na.map <- mutate(na.map, long = long- 360)

```

Finally, to map the paths, we set the x-axis and y-axis limits based on the location of receivers with detections. Note that if the tags were not deployed near towers with detections, the axis limits might need to be modified to encompass the deployment location of the tags. We use ggplot to plot the map and tag paths.

```{r mapDetections}

## set limits to map based on locations of detections, ensuring they include the deployment locations
xmin <- min(df.alltags.path$recvLon, na.rm = TRUE) - 2
xmax <- max(df.alltags.path$recvLon, na.rm = TRUE) + 2
ymin <- min(df.alltags.path$recvLat, na.rm = TRUE) - 2
ymax <- max(df.alltags.path$recvLat, na.rm = TRUE) + 2
                
## map
ggplot(na.lakes, aes(long, lat))+ 
  geom_polygon(data = na.map, aes(long, lat, group=group), colour = "grey", fill="grey98")+#
  geom_polygon(aes(group = group), colour = "grey", fill = "white")+
  coord_map(projection="mercator", xlim = c(xmin, xmax), ylim = c(ymin, ymax))+
  xlab("") + ylab("") + 
  theme_bw() + 
  geom_path(data = df.alltags.path, aes(recvLon, recvLat, group = motusTagID), colour = "grey20") + 
  geom_point(data = df.alltags.path, aes(recvLon, recvLat, colour = !is.na(ambigID), shape = (max.runLen > 2)), size =1.5)+
  geom_point(data = df.alltags.path, aes(tagDeployLon, tagDeployLat), colour = "black", shape = 4) +
  scale_colour_discrete("motusTagID") +
  scale_shape_manual(values = c(1, 2)) +
  scale_colour_manual(values = c("deepskyblue3", "darkorange1"))+
  facet_wrap(~motusTagID, nrow = 2)

```

**Figure 5.1.** Plot of the paths of several tags, showing whether detections were ambiguous (orange) or not (blue), and whether a detection had a run length of 2 (circle; implies a high probability of being false positive) or greater than 2 (triangle; higher probability of being a true detection). Tag deployment location is shown by a black 'x'. From the plot of tag paths, we can see that some of the ambiguous detections likely belong to other tags (e.g. tag 22897), and some non-ambiguous detections could be false positives. 

## Create a custom data filter for your .motus file

Throughout this chapter, we will generate a dataframe 'df.tagRuns' that includes the motusTagID and runID of detections we decide do not belong to our tags. Instead of filtering data to remove these false positive or ambiguous detections each time you work with your .motus file, you can create a custom data filter (see \@ref(#appendixC)) which is attached to your user profile (motus login credentials), and which can be used to 1) assign probabilities to your detections, and 2) filter your detections based on those probabilities. 

To create (but not populate) a filter that is attached to your .motus file, use the `createRunsFilter` function. In this case, we create a filter named 'filtAmbigFalsePos':

```{r createFilter, eval = FALSE}

createRunsFilter(sql.motus, 
                 filterName = "filtAmbigFalsePos", 
                 motusProjID = 176, 
                 descr = "filter to assign probability = 0 to false positive detections and ambiguities that belong to other tags (Chapter 5 in R Book)")

```

We can check that the filter was created using the 'listRunsFilters' function; note that the filter has been assigned a unique filterID of 1:

```{r listRunsFilters}

listRunsFilters(sql.motus)

```

## Filter detections data

Key things to look for to determine if detections are false positive include:

1) Run length: run length ('runLen') is the number of tag bursts in a run, and a run is a group of consecutive detections of a tag detected on a receiver. In general, a detection with a run length of 2 has a high probability of being a false positive detection. If you want to be conservative with your data filtering, you could simply filter out all detections with a run length of 2. We caution, however, that this has the potential to filter out true detections, and we therefore recommend that you examine which detections this filter would remove. In this chapter we don't automatically filter detections by run length, but we do use run length to help us decide which detections are likely to be true or not.

2) Standard deviation of frequency offset: Standard deviation of frequency offset among pulses in a burst ('freqsd'; in KHz) can also be used as a coarse and automatic data filter, by removing any values larger that 0.1, which suggests a false detection. This filter applies to data collected by SensorGnome receivers only. As with run length, it is recommended that you identify the detections you would be removing and examine them to ensure you aren't removing an unwanted amount of true detections.  As with run length, we don't automatically filter by freqsd in this chapter, and instead use it to help us decide whether detections are false positive or not.

3) detections in regions or at times of year that don't make biological sense for the study species.

4) consecutive detections at distant sites that would require biologically unreasonable flight speeds to be true.


### Filter detections with run length = 2 and standard deviation of frequency offset > 0.1

For demonstration, we re-plot the data, including only detections with runLen > 2 and freqsd < 0.1:

```{r mapDetections2}

df.alltags.path <- df.alltags.sub %>%
                    filter(tagProjID == proj.num, runLen > 2, freqsd < 0.1) %>% # keep to tags registered to the sample project
                    arrange(motusTagID, ts) %>%       # order data by time stamp for each motus tag ID
                    mutate(date = as_date(ts)) %>%    # create date variable
                    group_by(motusTagID, date, recvDeployName, ambigID, tagDeployLon, tagDeployLat, recvLat, recvLon)%>%
                    summarize(max.runLen = max(runLen)) 

## set limits to map based on locations of detections, ensuring they include the deployment locations
xmin <- min(df.alltags.path$recvLon, na.rm = TRUE) - 2
xmax <- max(df.alltags.path$recvLon, na.rm = TRUE) + 2
ymin <- min(df.alltags.path$recvLat, na.rm = TRUE) - 2
ymax <- max(df.alltags.path$recvLat, na.rm = TRUE) + 2
                
## map
ggplot(na.lakes, aes(long, lat))+ 
  geom_polygon(data = na.map, aes(long, lat, group=group), colour = "grey", fill="grey98")+#
  geom_polygon(aes(group = group), colour = "grey", fill = "white")+
  coord_map(projection="mercator", xlim = c(xmin, xmax), ylim = c(ymin, ymax))+
  xlab("") + ylab("") + 
  theme_bw() + 
  geom_path(data = df.alltags.path, aes(recvLon, recvLat, group = motusTagID), colour = "grey20") + 
  geom_point(data = df.alltags.path, aes(recvLon, recvLat, colour = !is.na(ambigID)), size =1.5)+
  geom_point(data = df.alltags.path, aes(tagDeployLon, tagDeployLat), colour = "black", shape = 4) +
  scale_colour_discrete("motusTagID") +
  #scale_shape_manual(values = c(1, 2)) +
  scale_colour_manual(values = c("deepskyblue3", "darkorange1"))+
  facet_wrap(~motusTagID, nrow = 2)

```
**Figure 5.2**. Plot of the paths of several tags, showing whether detections were ambiguous (orange) or not (blue), for detections with a run length greater than two and standard deviation of frequency offset > 0.1. and whether a detection had a run length of 2. Tag deployment location is shown by a black 'x'. We note that the paths are much cleaner than in Figure 5.1.

As stated above, removing all detections with a run length of 2 *might* remove true detections, particularly at sites with very little noise. Sometimes if a tag generates a few runs with runLen = 2 on different antennas at the same time, this could provide some support that the detection was a true detection. We can do the following to summarize situations in this dataset where there are more than two runs with run length of 2 for the same tag on more than one antenna (excluding detections with freqSD > 0.1):

```{r }

df.alltags.sub %>%
  filter(runLen == 2, freqsd < 0.1) %>%
  select(hitID, runID, batchID, ts, motusTagID, recvDeployName, port, freqsd) %>%
  mutate(date = date(ts)) %>%
  group_by(motusTagID, date, recvDeployName, batchID) %>%
  summarize(n.hits = length(unique(hitID)),
            n.runs = length(unique(runID)),
            n.ports = length(unique(port)),
            max.freqsd = max(freqsd, na.rm = TRUE)) %>%
  as.data.frame() %>%
  filter(n.runs > 1 & n.ports > 2)

```

We see in particular that the Niapiskau station has many instances where detections have runLen == 2, but many hits and runs on more than one antenna. This *might* suggest this site has little noise, and detections *might* therefore be more likely to be true. In this case, we will filter out all detections with runLen = 2, except from the Niapiskau station. To do so, we create a dataframe 'df.tagRuns' which contains the runID and motusTagID for detections that we want to remove from the data. This dataframe will then be used to populate the 'filtAmbigFalsePos' filter we created previously:

```{r filterRunLen}

df.tagRuns <- df.alltags.sub %>%
  filter(freqsd > 0.1|(runLen == 2 & recvDeployName != "Niapiskau")) %>%
  select(motusTagID, runID) %>%
  distinct()

```

#### Populate and apply filter

To add the runIDs in the 'df.tagRuns' dataframe to the custom filter, first assign a probability to each runID. In this case, we assign a probability of 0 because we have no confidence that they are true detections:

```{r addProb0}

df.tagRuns <- mutate(df.tagRuns, probability = 0) 
  
```

We then populate the 'filtAmbigFalsePos' filter with our list of runIDs using the `writeRunsFilter` function. If you wanted to remove any runIDs that were previously written to the filter, you can use the delete = TRUE option (we do not do that here):

```{r writeFilter}

writeRunsFilter(sql.motus, "filtAmbigFalsePos", motusProjID = 176, df = df.tagRuns)

```
We can check that the records were applied to the filter using the 'getRunsFilters' function:

```{r getRunsFilter}

df.check <- getRunsFilters(sql.motus, "filtAmbigFalsePos")
head(df.check)

```

Finally, apply the filter to the .motus file. Note also that unless the 'p.min' statement is used, applying the filter simply assigns each run of detections in the database with the probability you've assigned in the steps above. We filter the data by those probabilities by assigning a p.min = 0.1, which drops all detections associated with a probability < 0.1.

Note also that because the filter is applied to the .motus file and not our flat file, we need to re-create the flat file. Going forward, once the filter is completely populated, you will only need to do this when you first import the data. Here, we start from tagme() to show you how the filter would be applied when you first import your data:

```{r overwriteFilter}

# load the .motus file
sql.motus <- tagme(176, update = TRUE, dir = "./data/")

# apply the filter; a dataframe is output
df.alltags.filt <- applyRunsFilter(sql.motus, "filtAmbigFalsePos", p.min = 0.1)

# manage the dataframe
df.alltags.filt <- df.alltags.filt %>%
                      filter(motusTagID %in% tag.list$motusTagID) %>%
                      mutate(recvLat = if_else((is.na(gpsLat)|gpsLat == 0), recvDeployLat, gpsLat),
                             recvLon = if_else((is.na(gpsLon)|gpsLon == 0), recvDeployLon, gpsLon),
                             recvAlt = if_else(is.na(gpsAlt), recvDeployAlt, gpsAlt),
                             ts = as_datetime(ts),  # work with dates AFTER transforming to flat file
                             tagDeployStart = as_datetime(tagDeployStart),
                             tagDeployEnd = as_datetime(tagDeployEnd)) %>%
                      select(-noise, -slop, -burstSlop, -done, -bootnum, -mfgID, -codeSet, -mfg, -nomFreq, -markerNumber, -markerType, -tagDeployComments, -fullID, -deviceID, -recvDeployLat, -recvDeployLon, -recvDeployAlt, -speciesGroup, -gpsLat, -gpsLon, - recvAlt, - recvSiteName) %>%
                      collect() %>%
                      as.data.frame() %>%
                      mutate() 

```


### 1. Examine plots of tag paths

We re-plot the tag paths using the filtered data:

```{r mapDetections3}

df.alltags.path <- df.alltags.filt %>%
                    filter(tagProjID == proj.num) %>% # keep to tags registered to the sample project
                    arrange(motusTagID, ts) %>%       # order data by time stamp for each motus tag ID
                    mutate(date = as_date(ts)) %>%    # create date variable
                    group_by(motusTagID, date, recvDeployName, ambigID, tagDeployLon, tagDeployLat, recvLat, recvLon)%>%
                    summarize(max.runLen = max(runLen)) 

## set limits to map based on locations of detections, ensuring they include the deployment locations
xmin <- min(df.alltags.path$recvLon, na.rm = TRUE) - 2
xmax <- max(df.alltags.path$recvLon, na.rm = TRUE) + 2
ymin <- min(df.alltags.path$recvLat, na.rm = TRUE) - 2
ymax <- max(df.alltags.path$recvLat, na.rm = TRUE) + 2
                
## map
ggplot(na.lakes, aes(long, lat))+ 
  geom_polygon(data = na.map, aes(long, lat, group=group), colour = "grey", fill="grey98")+#
  geom_polygon(aes(group = group), colour = "grey", fill = "white")+
  coord_map(projection="mercator", xlim = c(xmin, xmax), ylim = c(ymin, ymax))+
  xlab("") + ylab("") + 
  theme_bw() + 
  geom_path(data = df.alltags.path, aes(recvLon, recvLat, group = motusTagID), colour = "grey20") + 
  geom_point(data = df.alltags.path, aes(recvLon, recvLat, colour = !is.na(ambigID)), size =1.5)+
  geom_point(data = df.alltags.path, aes(tagDeployLon, tagDeployLat), colour = "black", shape = 4) +
  scale_colour_discrete("motusTagID") +
  #scale_shape_manual(values = c(1, 2)) +
  scale_colour_manual(values = c("deepskyblue3", "darkorange1"))+
  facet_wrap(~motusTagID, nrow = 2)

```

From these plots, we can safely drop some ambiguous detections that belong to duplicate tags from other projects:

**motusTagID 16038:** 

From this plot, there are no obvious false positive detections for this tag.

**motusTagID 16047:** 

Again for this tag, there are no obvious false positive detections. The path follows an expected trajectory for a Red Knot departing on fall migration from the James Bay area.

**motusTagID 22897:**

- using 'clarify(sql.motus)', the ambiguous detections in the Great Lakes region could also belong to tag 24298 released by the Neonics project. Filtering the tag deployment metadata using 'filter(df.tagDeps.sub, tagID == 24298)', we see that that duplicate tag was released on the north shore of Lake Erie. Those ambiguities most likely belong to that tag, and can be dropped from our data.


```{r filter1Tag3}

df.tagRuns <- filter(df.alltags.filt, 
                     motusTagID == 22897, 
                     (!is.na(ambigID))) %>%
                  select(motusTagID, runID) %>%
                  distinct() %>%
                  bind_rows(df.tagRuns)

```

**motusTagID 22902:** 

- using 'clarify(sql.motus)', the ambiguous detections for this tag, which occur in the great lakes region, could also belong to motusTagID 22778 from the RBrownAMWO project or motusTagID 24303 from the Neonics project. The Neonics project deployed tags on the north shore of Lake Erie in Ontario, Canada, so ambiguous detections in that region can be safely removed from the sample data.

```{r filter1Tag4}

df.tagRuns <- filter(df.alltags.filt, 
                     motusTagID == 22902, 
                     (!is.na(ambigID))) %>%
                  select(motusTagID, runID) %>%
                  distinct() %>%
                  bind_rows(df.tagRuns)

```

**motusTagID 22905:**

- using 'filter(df.tagDeps.sub, tagID == 22905|tagID == 23319)', we see that this tag and tag 23319 were deployed by the James Bay Shorebird Project (Sample Project) within two weeks of each other, and from the same deployment location. As a result, most detections are ambiguous and cannot be assigned with confidence to either tag. All ambiguous detections will unfortunately be dropped for this tag and for tag 23319. Only non-ambiguous detections of tag 22905 between October 10 2016 when it was deployed, and October 15 2016 when tag 23319 were deployed, will be useful for looking at movement behaviour. 


```{r filter1Tag5}

df.tagRuns <- filter(df.alltags.filt, 
                     motusTagID == 22905, 
                     (!is.na(ambigID))) %>%
                  select(motusTagID, runID) %>%
                  distinct() %>%
                  bind_rows(df.tagRuns)

```

**motusTagID 23319:**

- as stated above for tag 22905, all ambiguous detections will be dropped for this tag, because they can't be assigned with confidence to either tag.

```{r filter1Tag6}

df.tagRuns <- filter(df.alltags.filt, 
                     motusTagID == 23319, 
                     (!is.na(ambigID))) %>%
                  select(motusTagID, runID) %>%
                  distinct() %>%
                  bind_rows(df.tagRuns)

```

#### Populate and apply the custom filter

To add the runIDs in the 'df.tagRuns' dataframe to the custom filter, first assign a probability to each runID. In this case, we assign a probability of 0 because we have no confidence that they are true detections:

```{r addProb0}

df.tagRuns <- mutate(df.tagRuns, probability = 0) %>%
  distinct() # this shouldn't be necessary, more a precaution to avoid duplicate records
  
```

We then populate the 'filtAmbigFalsePos' filter with our list of runIDs using the `writeRunsFilter` function. In this case, because we have continued to append new runIDs to the 'df.tagRuns' we created in the previous section, we can delete the existing records in the filter and re-populate it:

```{r writeFilter}

writeRunsFilter(sql.motus, "filtAmbigFalsePos", motusProjID = 176, df = df.tagRuns, delete = TRUE)

```
If you instead wanted to append new records to the filter, leaving previous records intact, you could use the overwrite = FALSE statement (not evaluated here):

```{r overwriteFilter, eval = FALSE}

writeRunsFilter(sql.motus, "filtAmbigFalsePos", df = df.tagRuns, overwrite = FALSE)

```

We can check that records were applied to the filter using the 'getRunsFilters' function:

```{r getRunsFilter}

df.check <- getRunsFilters(sql.motus, "filtAmbigFalsePos")
head(df.check)

```

Again, we apply the filter to the .motus file, and re-format the data into a flat file before we continue to the next step. Note that this code is *exactly* the same as in the previous section, the only difference is that the 'filtAmbigFalsePos' filter now contains more runIDs to filter out of the data:

```{r overwriteFilter}

# load the .motus file
sql.motus <- tagme(176, update = TRUE, dir = "./data/")

# apply the filter; a dataframe is output
df.alltags.filt <- applyRunsFilter(sql.motus, "filtAmbigFalsePos", p.min = 0.1)

# manage the dataframe
df.alltags.filt <- df.alltags.filt %>%
                      filter(motusTagID %in% tag.list$motusTagID) %>%
                      mutate(recvLat = if_else((is.na(gpsLat)|gpsLat == 0), recvDeployLat, gpsLat),
                             recvLon = if_else((is.na(gpsLon)|gpsLon == 0), recvDeployLon, gpsLon),
                             recvAlt = if_else(is.na(gpsAlt), recvDeployAlt, gpsAlt),
                             ts = as_datetime(ts),  # work with dates AFTER transforming to flat file
                             tagDeployStart = as_datetime(tagDeployStart),
                             tagDeployEnd = as_datetime(tagDeployEnd)) %>%
                      select(-noise, -slop, -burstSlop, -done, -bootnum, -mfgID, -codeSet, -mfg, -nomFreq, -markerNumber, -markerType, -tagDeployComments, -fullID, -deviceID, -recvDeployLat, -recvDeployLon, -recvDeployAlt, -speciesGroup, -gpsLat, -gpsLon, - recvAlt, - recvSiteName) %>%
                      collect() %>%
                      as.data.frame() %>%
                      mutate() 

```

Again, re-run the plot of tag paths to see that the paths are again much cleaner:

```{r plotPaths2, message = FALSE, warning = FALSE}

df.alltags.path <- df.alltags.filt %>%
                    filter(tagProjID == proj.num) %>% # keep to tags registered to the sample project
                    arrange(motusTagID, ts) %>%       # order data by time stamp for each motus tag ID
                    mutate(date = as_date(ts)) %>%    # create date variable
                    group_by(motusTagID, date, recvDeployName, ambigID, tagDeployLon, tagDeployLat, recvLat, recvLon)%>%
                    summarize(max.runLen = max(runLen)) 
## map
## set limits to map based on locations of detections, ensuring they include the deployment locations
xmin <- min(df.alltags.path$recvLon, na.rm = TRUE) - 2
xmax <- max(df.alltags.path$recvLon, na.rm = TRUE) + 2
ymin <- min(df.alltags.path$recvLat, na.rm = TRUE) - 2
ymax <- max(df.alltags.path$recvLat, na.rm = TRUE) + 2

ggplot(na.lakes, aes(long, lat))+ 
  geom_polygon(data = na.map, aes(long, lat, group=group), colour = "grey", fill="grey98")+#
  geom_polygon(aes(group = group), colour = "grey", fill = "white")+
  coord_map(projection="mercator", xlim = c(xmin, xmax), ylim = c(ymin, ymax))+
  xlab("") + ylab("") + 
  theme_bw() + 
  geom_path(data = df.alltags.path, aes(recvLon, recvLat, group = motusTagID), colour = "grey20") + 
  geom_point(data = df.alltags.path, aes(recvLon, recvLat, colour = !is.na(ambigID), shape = (max.runLen > 2)), size =1.5)+
  geom_point(data = df.alltags.path, aes(tagDeployLon, tagDeployLat), colour = "black", shape = 4) +
  scale_colour_discrete("motusTagID") +
  scale_shape_manual(values = c(1, 2)) +
  scale_colour_manual(values = c("deepskyblue3", "darkorange1"))+
  facet_wrap(~motusTagID, nrow = 2)

```

### Filter data based on geographic position (latitude/longitude) against time

Next, we visualize the time and location of detections relative to the time and location of tag deployments. When we plot the data, we want to include the deployment date and location of any duplicate tag, so we can visualize where detections fall relative to the tag deployments. Because we are plotting with a facet based on motusTagID, and not ambigID, we need to first manipulate the data, so that we end up with a deployment metadata table that has a 'tagID' variable which tells us which 'motusTagID' the deployment information belongs to, and a 'motusTagID' field which tells us which of our tags this deployment information should be plotted with (i.e., which tag it is a duplicate of). [THERE MUST BE A BETTER WAY?!!]

Note that if you have a large number of tags (say > 6) in your data, these plots will be messy, and you will want to plot each tag individually or in subsets of tags. 

```{r importTagMeta}

## get a list of the motusIDs for all of ambiguous IDs
df.allambigs <-  tbl(sql.motus, "allambigs") %>%
  collect() %>% 
  as.data.frame() 

df.myAmbigs <- df.allambigs %>%
  filter(motusTagID %in% tag.list$motusTagID)

## deployments in this table are the deployments of the duplicate tags (motusTagDup)
df.myDeps <- left_join(df.tagDeps.sub,
                          df.allambigs,
                          by = c("tagID" = "motusTagID"))

## merge again, creating a new variable with both the projectID
## and the MotusTagID which makes it easier for plotting to see where
## the various ambiguous come from.

df.myDeps <- left_join(df.myDeps, df.myAmbigs, by = "ambigID") %>%
  mutate(plot.id = paste(ambigID, tagID, projectID, sep = "."),
         motusTagID = if_else(is.na(motusTagID), tagID, motusTagID))

```

**Plot latitude of detections against time.**

```{r plotLatbyTime, fig.width=11, fig.height=6}

ggplot(data = filter(df.alltags.filt, is.na(ambigID)), # plot ambiguous detections first
            aes(ts, recvLat)) +
  geom_point(size = 1, shape = 1) +
  geom_point(data = filter(df.alltags.filt, !is.na(ambigID)), aes(ts, recvLat), size = 1, shape = 2) + # add non-ambiguous detections
  geom_point(data = df.myDeps, aes(tsStart, latitude, colour = plot.id), size = 2, shape = 13) +
  facet_wrap(~ motusTagID, ncol= 3, scales = "free") + 
  theme_bw() +   
  ylab("Latitude") + xlab("Date") +
  guides(colour=guide_legend(title="id.motusTagID.projectID")) 

```
**Plot longitude of detections against time.**

```{r plotLonbyTime}

ggplot(data = filter(df.alltags.filt, is.na(ambigID)), # plot ambiguous detections first
            aes(ts, recvLon)) +
  geom_point(size = 1, shape = 1) +
  geom_point(data = filter(df.alltags.filt, !is.na(ambigID)), aes(ts, recvLon), size = 1, shape = 2) + # add non-ambiguous detections
  geom_point(data = df.myDeps, aes(tsStart, longitude, colour = plot.id), size = 2, shape = 13) +
  facet_wrap(~ motusTagID, ncol= 3, scales = "free") + 
  theme_bw() +   
  ylab("Longitude") + xlab("Date") +
  guides(colour=guide_legend(title="id.motusTagID.projectID")) 

```

**motusTagID 16038**

- there are detections at two towers, not far apart. From these plots, there don't appear to be additional false positives for this tag.

**motusTagID 16047**

- there is nothing that stands out about these detections that requires filtering in this step; you can see that after this Red Knot departed the James Bay region, it was detected moving south along the east coast at an appropriate time of year and in an appropriate location.

**motusTagID 22897**

- using 'filter(df.alltags.filt, motusTagID == 22897, recvLon < -80)', we see that the detections in the Great Lakes region (recvDeployName "Old Cut") occurred on April 20, 2017 at 22:33 (HH:MM). The detections have a run length of 3 or 4, freqsd is < 0.1, and detections were recorded by three of four antennas at the Old Cut station. Normally Red Knots migrate through that region in May, so this is potentially a little bit early to detect Red Knots at this tower, but not impossible. 

**motusTagID 22902**

- the only detections for this tag occur at the deployment location, near the deployment time, so these are true detections of the tag.

**5. motusTagID 22905**

- I can't finish this and the next tag until the filter is working properly

**motusTagID 23319**

### Filter data based on flight speed between detections {#filterFlightSpeed}

By looking at the rate of movement between sites with consecutive detections, we can often quickly view flights that are not physically possible. At this point, our data is looking pretty clean, but we want to be thorough.

Rate of movement between sites can be determined using the siteTrans function in the motus R package (see \@ref(#appendixB). The output is in m for distance, and m/s for rate. 

```{r falseBySpeed1, message = FALSE, warning = FALSE}

# REMOVE THE FOLLOWING LINE WHEN FILTER WORKING PROPERLY
df.alltags.filt <- filter(df.alltags.filt, is.na(ambigID))

df.detectTrans <- as.data.frame(siteTrans(df.alltags.filt, latCoord = "recvLat", lonCoord = "recvLon")) ## create new data.base consisting of transitions between consecutive sites for each tag
head(df.detectTrans)
summary(df.detectTrans)

```

There are a few transitions with unusually high speeds. We subset those out to take a closer look:

```{r falseBySpeed2}

filter(df.detectTrans, rate > 60)

df.detectTrans %>%
  group_by(motusTagID) %>%
  summarize()
```

All of the high rates are for one tag, 16047, attached to a Red Knot, and appear to be the result of simultaneous detections by the BennetMeadow and Shelbourne sites, which are within 20km of each other north of Amherst Massachusetts, and 7 hours later by the the BISE and TRUS stations, which are within 30 km of each other on the east coast near Rhode Island. These are not false positive detections, rather, this method of estimating distance and speed is inappropriate in this circumstance, because the bird is most likely migrating somewhere between the two towers.

