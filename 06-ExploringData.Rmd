# Exploring data with the Motus R package {#exploreData}

Once you have clarified any possible ambiguous tags, and removed false positives, you are ready to start analyzing your clean data set.  This chapter will walk you through some simple procedures to start working with and visualizing the clean sample data set, you can modify these scripts to work with your data. For a more indepth totorial we strongly recommend working through R for Data Science by Garrett Grolemund and Hadley Wickham <http://r4ds.had.co.nz/>.

## Load required packages

Follow the instructions in Chapter \@ref(loadingPackages) to install the following packages before loading, if you haven't already done so.

```{r loadpackages.6, message = FALSE, warning = FALSE}

library(motus)

```


```{r setTimeZone2 }

Sys.setenv(TZ="GMT")

```


## Load data

If you followed along with the the previous \@ref(dataCleaning) chapter and are working with cleaned 'df.alltags.sub' file, you can skip this step and move to \@ref(dataSummaries).  Otherwise we will load the previously downloaded sample data (see chapter \@ref(accessingData) and clean it now.

```{r importData}

# load the .motus file
sql.motus <- tagme(176, update = FALSE, dir = "./data/")

## apply the filter; a dataframe is output -- keep all values for now, so that you 
## still have access to low probability detections for checking

tbl.alltags.sub <- applyRunsFilter(sql.motus, "filtAmbigFalsePos", p.min = 0.1)

# convert the table into a dataframe, with a few modications
df.alltags.sub <- tbl.alltags.sub %>%
                      mutate(recvLat = if_else((is.na(gpsLat)|gpsLat == 0), recvDeployLat, gpsLat),
                             recvLon = if_else((is.na(gpsLon)|gpsLon == 0), recvDeployLon, gpsLon),
                             recvAlt = if_else(is.na(gpsAlt), recvDeployAlt, gpsAlt)) %>%
                      select(-noise, -slop, -burstSlop, -done, -bootnum, -codeSet, -mfg, -nomFreq,
                             -markerNumber, -markerType, -tagDeployComments, -fullID, -deviceID,
                             -recvDeployLat, -recvDeployLon, -recvDeployAlt, -speciesGroup, -gpsLat,
                             -gpsLon, - recvAlt, - recvSiteName) %>%
                      collect() %>%
                      as.data.frame() %>%
                      mutate(ts = as_datetime(ts),  # work with dates AFTER transforming to flat file
                             tagDeployStart = as_datetime(tagDeployStart),
                             tagDeployEnd = as_datetime(tagDeployEnd))

```

Note that if your project is very large, you may want to convert only a portion of it to the dataframe, to avoid memory issues. You can do so by adding a filter to the above command (in this case, only creating a dataframe for motusTagID 16047):

```{r importData}

# create a subset for a single tag, to keep the dataframe small
df.alltags.16047 <- tbl.alltags.sub %>%
                      mutate(recvLat = if_else((is.na(gpsLat)|gpsLat == 0), recvDeployLat, gpsLat),
                             recvLon = if_else((is.na(gpsLon)|gpsLon == 0), recvDeployLon, gpsLon),
                             recvAlt = if_else(is.na(gpsAlt), recvDeployAlt, gpsAlt)) %>%
                      select(-noise, -slop, -burstSlop, -done, -bootnum, -codeSet, -mfg, -nomFreq,
                             -markerNumber, -markerType, -tagDeployComments, -fullID, -deviceID,
                             -recvDeployLat, -recvDeployLon, -recvDeployAlt, -speciesGroup, -gpsLat,
                             -gpsLon, - recvAlt, - recvSiteName) %>%
                      filter(motusTagID == 16047) %>%
                      collect() %>%
                      as.data.frame() %>%
                      mutate(ts = as_datetime(ts),  # work with dates AFTER transforming to flat file
                             tagDeployStart = as_datetime(tagDeployStart),
                             tagDeployEnd = as_datetime(tagDeployEnd))


```

## Summarizing your data {#dataSummaries}
Here we will run through some basic commands, starting with the summary() function to view all variables in a data frame, here we'll just examine a few select variables:

```{r summaryAllTags}

sql.motus %>% 
  tbl("alltags") %>% 
  select(ts, motusTagID, runLen, speciesEN, tagDeployLat, tagDeployLon, 
         recvDeployLat, recvDeployLon) %>% 
  collect() %>%
  summary()

# same summary for the filtered data
tbl.alltags.sub %>% 
  select(ts, motusTagID, runLen, speciesEN, tagDeployLat, tagDeployLon, 
         recvDeployLat, recvDeployLon) %>% 
  collect() %>%
  summary()

```

The dplyr package allows you to easily summarize data by group, manipulate variables, or create new variables based on your data.  

We can manipulate existing variables or create new ones with dplyr's mutate function, here we'll convert ts to a POSIXct format, then make a new variable for year and day of year (doy).

We'll also remove the set of points with missing receiver latitude and longitudes. These may be useful in some contexts (for example if the approximate location of the receiver is known) but can cause warnings or errors when plotting. 

```{r tagMutate}

df.alltags.sub <- df.alltags.sub %>%
  mutate(ts = as_datetime(ts, tz = "UTC"), ## convert ts to POSIXct format
         year = year(ts), ## extract year from ts
         doy = yday(ts)) %>% ## extract numeric day of year from ts
  filter(!is.na(recvLat))
head(df.alltags.sub)

```

We can also summarize information by group, in this case motusTagID, and apply various functions to these groups such as getting the total number of detections (n) for each tag, the number of receivers each tag was detected on, the first and last detection date, and the total number of days there was at least one detection:
```{r tagSummary}

tagSummary <- df.alltags.sub %>%
  group_by(motusTagID) %>% 
  summarize(nDet = n(),
            nRecv = length(unique(recvDeployName)),
            tsMin = min(ts),
            tsMax = max(ts),
            totDay = length(unique(doy)))

head(tagSummary)

```

We can also group by multiple variables, applying the same function as above but now grouping by motusTagID and recvDeployName, we will get information for each tag detected on each receiver. Since we've specified to group by recvDeployName, there will be by default only one recvDeployName in each group, thus the variable nRecv will be 1 for each row which is not very information, however we've kept this variable in to help illustrate how grouping works:
```{r tagRecvSum}

tagRecvSummary <- df.alltags.sub %>%
  group_by(motusTagID, recvDeployName) %>% 
  summarize(nDet = n(),
            nRecv = length(unique(recvDeployName)),
            tsMin = min(ts),
            tsMax = max(ts),
            totDay = length(unique(doy)))

head(tagRecvSummary)

```

## Plotting your data {#dataPlotting}
Plotting your data is a powerful way to visualize broad and fine-scale detection patterns, this section will give you a brief intro into plotting using ggplot2.  For more in depth information on the uses of ggplot2 we recommend the Cookbook for R <http://www.cookbook-r.com/Graphs/>, and the rstudio ggplot2 cheatsheet <https://www.rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf>.  

To make coarse-scale plots with large files we suggest first rounding the detection time to the nearest hour or day so that processing time is faster.  Here we'll round detection times to the nearest hour and work with that rounded dataframe, then we'll make a basic plot of hourly detections by motusTagID:

```{r hourlyPlot}
df.alltags.sub.2 <- mutate(df.alltags.sub, 
                         hour = as.POSIXct(round(ts, "hour"))) %>% 
  select(motusTagID, port, mfgID, tagDeployStart, tagDeployLat, tagDeployLon, 
         recvLat, recvLon, recvDeployName, antBearing, speciesEN, year, doy, hour) %>% 
  distinct()

p <- ggplot(data = df.alltags.sub.2, aes(hour, as.factor(motusTagID))) 
p + geom_point() + 
  ylab("MotusTagID") + xlab("Time (rounded to hour)") + 
  theme_bw()
```
Let's focus only on tags deployed in 2016, we can also clean up the plot by removing the grey background, and we can colour the tags by species:

```{r hourlyPlotSpecies}
p <- ggplot(data = filter(df.alltags.sub.2, year(tagDeployStart) == 2016), 
       aes(hour, as.factor(motusTagID), col = speciesEN)) 
p + geom_point() +
  xlab("Time (rounded to hour)") + ylab("MotusTagID") +
  scale_colour_discrete(name = "Species")
  theme_bw()
```

We can see how tags moved latitudinally by first ordering by hour:

```{r hourlyPlotLat, warnings = FALSE}

df.alltags.sub.2 <- arrange(df.alltags.sub.2, hour)

p <- ggplot(data = filter(df.alltags.sub.2, year(tagDeployStart) == 2016), 
       aes(hour, recvLat, col = as.factor(motusTagID), group = as.factor(motusTagID)))
p +  geom_point() +
  geom_path() +
  theme_bw() + xlab("Time (rounded to hour)") + ylab ("Receiver latitude") +
  scale_colour_discrete(name = "MotusTagID")
```

Now lets look at more detailed plots of signal variation, here we'll use the full df.alltags.sub dataframe so we can get signal strength for each detection of a specific tag.  Let's examine fall 2016 detections of tag 22897 at Niapiskau, we can facet the plot by deployment name, ordered by decreasing latitude.


```{r plot22897}

p <- ggplot(filter(df.alltags.sub, 
                   motusTagID == 22897, 
                   recvDeployName == "Niapiskau"), 
       aes(ts, sig)) 
p +  theme_bw() + 
  geom_point() + 
  xlab("Time") + ylab("Signal strength") +
  facet_grid(recvDeployName~.)

```

We can use the sunRiseSet function available in the motus R package (see \@ref(sunRiseSet)) to get sunrise and sunset times for all detections, we can then add that information to the above plot with geom_vline()

```{r plotSunriset22897}
## add sunrise and sunset times to the dataframe
df.alltags.sub <- sunRiseSet(df.alltags.sub, lat = "recvLat", lon = "recvLon") 

p <- ggplot(filter(df.alltags.sub, motusTagID == 22897 & 
                     ts > ymd("2016-10-11") & ts < ymd("2016-10-17") & 
                     recvDeployName == "Niapiskau"), 
            aes(ts, sig))

p + theme_bw() + 
  geom_point() + 
  xlab("Time of year") + ylab("Signal strength") +
  geom_vline(xintercept = df.alltags.sub$sunrise, col = "orange") + 
  geom_vline(xintercept = df.alltags.sub$sunset, col = "blue")

```
We can see that during this period, the tag was most often detected during the day, suggesting it may be actively foraging in this area during this time.  

The same plots can provide valuable movement information (when the receivers are ordered geographically), here we'll look at motusTagID 16039:
```{r}
## We'll first order sitelat by latitude (for plots)
df.alltags.sub <- mutate(df.alltags.sub, 
                         recvDeployName = reorder(recvDeployName, recvLat)) 

p <- ggplot(filter(df.alltags.sub, motusTagID == 16039 & 
                     ts < ymd("2015-10-01")), 
       aes(ts, recvDeployName))

p + theme_bw() + 
  geom_point() + 
  xlab("Time of year") + ylab("Receiver name (ordered by latitude)")
```
We can zoom in on a section of this plot and look at antenna bearings to see directional movement past stations:

```{r}
p <- ggplot(filter(df.alltags.sub, motusTagID == 16039, 
                   ts > ymd("2015-09-14"), ts < ymd("2015-10-01")), 
            aes(ts, sig, col = as.factor(antBearing))) 
p + theme_bw() + 
  geom_point() + 
  xlab("Time of day") + ylab("Signal strength") +
  scale_color_discrete(name = "Antenna bearing")
  facet_grid(recvDeployName~.)
```
This plot shows the typical flyby pattern of a migrating bird, with signal strength increasing and  decreasing as the tag moves through the beams of the antennas.

## Mapping your data {#mappingData}

To generate maps of tag paths, we will once again use summarized data so we can work with a much smaller database for faster processing. Here we'll summarize detections by day. As we did in Chapter 5, well create a simple function to do this, since we will likely want to use it over and over again. 

```{r fun.getpath}

## simplify the data by summarizing by the runID. 
## if you want to summarize at a finer (or coarser) scale, you can also create other groups.  
## The simplest alternative is a rounded timestamp variable; for example by using 
## mutate(ts.h = plyr::round_any(ts, 3600) function call. 
## Other options are to just use date (e.g date = as_date(ts))

## 
fun.getpath <- function(df) 
  {
  df %>%
    filter(tagProjID == proj.num, # keep only tags registered to the sample project
                           !is.na(recvLat) | !(recvLat == 0)) %>% 
    group_by(motusTagID, runID, recvDeployName, ambigID, 
             tagDeployLon, tagDeployLat, recvLat, recvLon) %>%
    summarize(max.runLen = max(runLen), ts.h = mean(ts)) %>%
    arrange(motusTagID, ts.h)
  } ## end of function call

df.alltags.path <- fun.getpath(df.alltags.sub)
                    
```


```{r plotTagPaths.6}

df.alltags.sub.path <- df.alltags.sub %>%
                    filter(tagProjID == proj.num) %>% # keep to tags registered to the sample project
                    arrange(motusTagID, ts) %>%       # order data by time stamp for each motus tag ID
                    mutate(date = as_date(ts)) %>%    # create date variable
                    group_by(motusTagID, date, recvDeployName, ambigID, tagDeployLon, tagDeployLat, recvLat, recvLon)

df.alltags.path <- fun.getpath(df.alltags.sub)
```

### Mapping with Google Maps {#googleMaps}

Mapping with Google Maps can be a fast way to view flight paths that allows you to select from multiple base layers.  

For Google Maps, we'll need to load ggmap and ggplot2 packages, see \@ref(loadingPackages) for instructions on installing the package if you have no already done so.

```{r installGoogleMapPackages, message = FALSE, warning = FALSE, eval = FALSE}

require(ggmap)

```

The first step is creating a map with a specified map centre, maptype ("terrain", "roadmap", "satellite", or "hybrid"), and level of zoom (integer for zoom 3-21, 3 being continent level, 10 being city-scale).  We then add points for receivers and lines connecting consecutive detections by motusTagID.

```{r googleMap, warning = FALSE, fig.width=10, fig.height=10}

gmap <-  get_map(location = c(lon = -75, lat = 40), ## lon/lat to centre map over
                 maptype = "satellite", ## select maptype
                 source = "google",
                 zoom = 4) ## zoom, must be a whole number

## just use the tags that we have examined carefully and filtered (in the previous chapter)
df.tmp <- filter(df.alltags.path, 
                           motusTagID %in% c(16011, 16035, 16036, 16037, 16038, 16039))
p <- ggmap(gmap)
p + geom_point(data=df.tmp, 
               aes(recvLon, recvLat), pch=21, colour = "black", fill = "yellow") +
  geom_path(data=df.tmp, 
            aes(recvLon, recvLat, group=motusTagID, col = as.factor(motusTagID))) +
  theme_bw() + 
  scale_color_discrete(name="MotusTagID")

```

### Creating simple outline maps {#outlineMaps}
For mapping with outline maps, we'll need to load the rworldmap package, see \@ref(loadingPackages) for instructions on installing the package if you have no already done so.

```{r installMapPackages, message = FALSE, warning = FALSE, eval = FALSE}

require(rworldmap)

```

We first need to load the base maps.

```{r loadMaps.6, message = FALSE, warning = FALSE}

na.lakes <- map_data(map = "lakes")
na.lakes <- mutate(na.lakes, long = long- 360)

# Include all of the Americas to begin
na.map <- subset(map_data(map="world2"), 
                 region %in% c("Canada", "USA", "Mexico", "lakes",
                               "Belize", "Costa Rica", "Panama", 
                               "Guatemala", "Honduras", "Nicaragua", 
                               "El Salvador", "Colombia", "Venezuela", "Ecuador", "Peru", "Brazil",
                               "Guyana","Suriname", "Bolivia", "French Guiana", "Jamaica", "Cuba", 
                               "Haiti", "Dominican Republic", "The Bahamas", "Turks and Caicos Islands", 
                               "Puerto Rico", "British Virgin Islands", "Montserrat", "Dominica", "Saint Lucia", "Barbados", "Grenada", "Trinidad and Tobago", "Chile", "Argentina", "Uruguay", "Paraguay"))

na.map <- mutate(na.map, long = long- 360)

```

Finally, to map the paths, we set the x-axis and y-axis limits based on the location of receivers with detections. Depending on your data, these might need to be modified to encompass the deployment location of the tags, if tags were not deployed near towers with detections. We then use ggplot to plot the map and tag paths.  Here we use the Mercator projection and are colouring the paths by motusTagID, including a point for where the tag was deployed

```{r mapDetections}

# set limits to map based on locations of detections, ensuring they include the deployment locations
xmin <- min(df.tmp$recvLon, na.rm = TRUE) - 2
xmax <- max(df.tmp$recvLon, na.rm = TRUE) + 2
ymin <- min(df.tmp$recvLat, na.rm = TRUE) - 2
ymax <- max(df.tmp$recvLat, na.rm = TRUE) + 2
                
# map
ggplot(na.lakes, aes(long, lat))+ 
  geom_polygon(data = na.map, aes(long, lat, group=group), colour = "grey", fill="grey98")+#
  geom_polygon(aes(group = group), colour = "grey", fill = "white")+
  coord_map(projection="mercator", xlim = c(xmin, xmax), ylim = c(ymin, ymax))+
  xlab("") + ylab("") + 
  theme_bw() + 
  geom_path(data = df.tmp, 
            aes(recvLon, recvLat, group = "motusTagID", colour = as.factor(motusTagID))) +
  geom_point(data = df.tmp, 
             aes(tagDeployLon, tagDeployLat), colour = "black", shape = 4) +
  scale_colour_discrete("motusTagID") 

```

The functions above provide examples for you how can begin exploring your data and are by no means exhaustive. The next chapter will cover some common errors and troubleshooting you may encounter while trying to download and use the .motus sql files.

