# Exploring data with the Motus R package {#exploreData}

Once you have clarified any possible ambiguous tags, and removed false positives, you are ready to start analyzing your clean data set.  This chapter will walk you through some simple procedures to start working with and visualizing the clean sample data set, you can modify these scripts to work with your data. For a more indepth totorial we strongly recommend working through R for Data Science by Garrett Grolemund and Hadley Wickham <http://r4ds.had.co.nz/>.

## Load required packages

Follow the instructions in Chapter \@ref(loadingPackages) to install the following packages before loading, if you haven't already done so.

```{r loadpackages.6, message = FALSE, warning = FALSE}

library(motus)

```

## Load data

If you followed along with the the previous \@ref(dataCleaning) chapter and are working with cleaned 'df.alltags.filt.filt' file, you can skip this step and move to \@ref(dataSummaries).  Otherwise we will load the previously downloaded sample data (see chapter \@ref(accessingData) and clean it now.

```{r importData}

# load the .motus file
sql.motus <- tagme(176, update = FALSE, dir = "./data/")

# apply the filter; a dataframe is output
df.alltags.filt.filt <- applyRunsFilter(sql.motus, "filtAmbigFalsePos", p.min = 0.1)

# manage the dataframe
df.alltags.filt.filt <- df.alltags.filt.filt %>%
                      mutate(recvLat = if_else((is.na(gpsLat)|gpsLat == 0), recvDeployLat, gpsLat),
                             recvLon = if_else((is.na(gpsLon)|gpsLon == 0), recvDeployLon, gpsLon),
                             recvAlt = if_else(is.na(gpsAlt), recvDeployAlt, gpsAlt),
                             ts = as_datetime(ts),  # work with dates AFTER transforming to flat file
                             tagDeployStart = as_datetime(tagDeployStart),
                             tagDeployEnd = as_datetime(tagDeployEnd)) %>%
                      select(-noise, -slop, -burstSlop, -done, -bootnum, -codeSet, -mfg, -nomFreq, -markerNumber, -markerType, -tagDeployComments, -fullID, -deviceID, -recvDeployLat, -recvDeployLon, -recvDeployAlt, -speciesGroup, -gpsLat, -gpsLon, - recvAlt, - recvSiteName) %>%
                      collect() %>%
                      as.data.frame()
```

## Summarizing your data {#dataSummaries}
Here we will run through some basic commands, starting with the summary() function to view all variables in a data frame, here we'll just examine a few select variables:
```{r summaryAllTags}

sql.motus %>% tbl("alltags") %>% select(ts, motusTagID, runLen, speciesEN, tagDeployLat, tagDeployLon, recvDeployLat, recvDeployLon) %>% collect %>% summary()

```

The dplyr package allows you to easily summarize data by group, manipulate variables, or create new variables based on your data.  

We can manipulate existing variables or create new ones with dplyr's mutate function, here we'll convert ts to a POSIXct format, then make a new variable for year and day of year (doy):
```{r tagMutate}

df.alltags.filt.filt <- df.alltags.filt.filt %>%
  mutate(ts = as_datetime(ts, tz = "UTC"), ## convert ts to POSIXct format
         year = year(ts), ## extract year from ts
         doy = yday(ts)) ## extract numeric day of year from ts
head(df.alltags.filt.filt)
```

We can also summarize information by group, in this case motusTagID, and apply various functions to these groups such as getting the total number of detections (n) for each tag, the number of receivers each tag was detected on, the first and last detection date, and the total number of days there was at least one detection:
```{r tagSummary}

tagSummary <- df.alltags.filt %>%
  group_by(motusTagID) %>% 
  summarize(nDet = n(),
            nRecv = length(unique(recvDeployName)),
            tsMin = min(ts),
            tsMax = max(ts),
            totDay = length(unique(doy)))
head(tagSummary)

```

We can also group by multiple variables, applying the same function as above but now grouping by motusTagID and recvDepName, we will get information for each tag detected on each receiver. Since we've specified to group by recvDeployName, there will be by default only one recvDeployName in each group, thus the variable nRecv will be 1 for each row which is not very information, however we've kept this variable in to help illustrate how grouping works:
```{r tagRecvSum}

tagRecvSummary <- df.alltags.filt %>%
  group_by(motusTagID, recvDeployName) %>% 
  summarize(nDet = n(),
            nRecv = length(unique(recvDeployName)),
            tsMin = min(ts),
            tsMax = max(ts),
            totDay = length(unique(doy)))
head(tagRecvSummary)

```

## Plotting your data {#dataPlotting}
Plotting your data is a powerful way to visualize broad and fine-scale detection patterns, this section will give you a brief intro into plotting using ggplot2.  For more in depth information on the uses of ggplot2 we recommend the Cookbook for R <http://www.cookbook-r.com/Graphs/>, and the rstudio ggplot2 cheatsheet <https://www.rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf>.  

To make coarse-scale plots with large files we suggest first rounding the detection time to the nearest hour or day so that processing time is faster.  Here we'll round detection times to the nearest hour and work with that rounded dataframe, then we'll make a basic plot of hourly detections by motusTagID:

```{r hourlyPlot}
df.alltags.filt$hour <- as.POSIXct(round(df.alltags.filt$ts, "hour"))
round.df.alltags.filt <- df.alltags.filt %>% filter(tagProjID == 176) %>% select(motusTagID, port, mfgID, tagDeployStart, tagDeployLat, tagDeployLon, recvLat, recvLon, recvDeployName, antBearing, speciesEN, year, doy, hour) %>% unique()

ggplot(data = round.df.alltags.filt, aes(hour, as.factor(motusTagID))) + geom_point()
```
Let's focus only on tags deployed in 2016, we can also clean up the plot by removing the grey background, and we can colour the tags by species:
```{r hourlyPlotSpecies}
ggplot(data = filter(round.df.alltags.filt, year(tagDeployStart) == 2016), aes(hour, as.factor(motusTagID), col = speciesEN)) +
  geom_point() +
  theme_bw()
```

We can see how tags moved latitudinally by first ordering by hour:
```{r hourlyPlotLat, warnings = FALSE}

round.df.alltags.filt <- arrange(round.df.alltags.filt, hour)

ggplot(data = filter(round.df.alltags.filt, year(tagDeployStart) == 2016), aes(hour, recvLat, col = as.factor(motusTagID), group = as.factor(motusTagID))) +
  geom_point() +
  geom_path() +
  theme_bw()
```

Now lets look at more detailed plots of signal variation, here we'll use the full df.alltags.filt dataframe so we can get signal strength for each detection of a specific tag.  Let's examine fall 2016 detections of tag 22897 at Niapiskau, we can facet the plot by deployment name, ordered by decreasing latitude.

16047 22867 23316 16037 16038 16039 16044 16011 19129 17021 17357 24298 16035 16052 22778 24303 16036 16048 22897 22902
[21] 22905 10811

```{r plot22897}
df.alltags.filt <- within(df.alltags.filt, recvDepName <- reorder(recvDeployName, (-recvLat))) ## order sitelat by decreasing latitude

ggplot(filter(df.alltags.filt, motusTagID == 22897 & recvDeployName == "Niapiskau"), aes(ts, sig)) + theme_bw() + geom_point() + facet_grid(recvDeployName~.)
```

We can use the sunRiseSet function available in the motus R package (see \@ref(sunRiseSet)) to get sunrise and sunset times for all detections, we can then add that information to the above plot with geom_vline()
```{r plotSunriset22897}
df.alltags.filt <- sunRiseSet(df.alltags.filt, lat = "recvLat", lon = "recvLon") ## add sunrise and sunset times to the dataframe

ggplot(filter(df.alltags.filt, motusTagID == 22897 & ts > as.POSIXct("2016-10-11") & ts < as.POSIXct("2016-10-17") & recvDepName == "Niapiskau"), aes(ts, sig)) + theme_bw() + geom_point() + geom_vline(xintercept = df.alltags.filt$sunrise, col = "orange") + geom_vline(xintercept = df.alltags.filt$sunset, col = "blue")
```
We can see that during this period, the tag was most often detected during the day, suggesting it may be actively foraging in this area during this time.  

The same plots can provide valuable movement information, here well look at motusTagID 16039:
```{r}
ggplot(filter(df.alltags.filt, motusTagID == 16039 & ts < as.POSIXct("2015-10-01")), aes(ts, sig)) + theme_bw() + geom_point() + facet_grid(recvDepName~.)
```
We can zoom in on a section of this plot and look at antenna bearings to see directional movement past stations:
```{r}
ggplot(filter(df.alltags.filt, motusTagID == 16039 & ts > as.POSIXct("2015-09-14") &ts < as.POSIXct("2015-10-01")), aes(ts, sig, col = as.factor(antBearing))) + theme_bw() + geom_point() + facet_grid(recvDepName~.)
```
This plot shows the typical flyby pattern of a migrating bird, signal strength increases and then decreases as the tag approaches and moves past the station.

## Mapping your data {#mappingData}
To generate maps of tag paths, we will once again use summarized data so we can work with a much smaller database for faster processing, here we'll summarize detections by day:
```{r plotTagPaths.6}
proj.num = 176

df.alltags.filt.path <- df.alltags.filt %>%
                    filter(tagProjID == proj.num) %>% # keep to tags registered to the sample project
                    arrange(motusTagID, ts) %>%       # order data by time stamp for each motus tag ID
                    mutate(date = as_date(ts)) %>%    # create date variable
                    group_by(motusTagID, date, recvDepName, ambigID, tagDeployLon, tagDeployLat, recvLat, recvLon)
```
### Mapping with Google Maps {#googleMaps}
Mapping with Google Maps can be a fast way to view flight paths that allows you to select from multiple base layers.  
For Google Maps, we'll need to load ggmap and ggplot2 packages, see \@ref(loadingPackages) for instructions on installing the package if you have no already done so.
```{r installGoogleMapPackages, message = FALSE, warning = FALSE, eval = FALSE}
require(ggmap)
```

The first step is creating a map with a specified map centre, maptype ("terrain", "roadmap", "satellite", or "hybrid"), and level of zoom (integer for zoom 3-21, 3 being continent level, 10 being city-scale).  We then add points for receivers and lines connecting consecutive detections by motusTagID.
```{r googleMap, warning = FALSE}
gmap <-  get_map(location = c(lon = -75, lat = 40), ## lon/lat to centre map over
                 maptype = "satellite", ## select maptype
                 source = "google",
                 zoom = 4) ## zoom, must be a whole number
  p <- ggmap(gmap)
  p + geom_point(data = df.alltags.filt.path, aes(recvLon, recvLat), pch=21, colour = "black", fill = "yellow") + geom_path(data=df.alltags.filt.path, aes(recvLon, recvLat, group=motusTagID, col = as.factor(motusTagID))) +
    theme_bw()

```

### Creating simple outline maps {#outlineMaps}
For mapping with outline maps, we'll need to load the rworldmap package, see \@ref(loadingPackages) for instructions on installing the package if you have no already done so.
```{r installMapPackages, message = FALSE, warning = FALSE, eval = FALSE}
require(rworldmap)
```

Now we need to load the base maps

```{r loadMaps.6, message = FALSE, warning = FALSE}

na.lakes <- map_data(map = "lakes")
na.lakes <- mutate(na.lakes, long = long- 360)

# Include all of the Americas to begin
na.map <- subset(map_data(map="world2"), 
                 region %in% c("Canada", "USA", "Mexico", "lakes",
                               "Belize", "Costa Rica", "Panama", 
                               "Guatemala", "Honduras", "Nicaragua", 
                               "El Salvador", "Colombia", "Venezuela", "Ecuador", "Peru", "Brazil",
                               "Guyana","Suriname", "Bolivia", "French Guiana", "Jamaica", "Cuba", 
                               "Haiti", "Dominican Republic", "The Bahamas", "Turks and Caicos Islands", 
                               "Puerto Rico", "British Virgin Islands", "Montserrat", "Dominica", "Saint Lucia", "Barbados", "Grenada", "Trinidad and Tobago", "Chile", "Argentina", "Uruguay", "Paraguay"))

na.map <- mutate(na.map, long = long- 360)

```

Finally, to map the paths, we set the x-axis and y-axis limits based on the location of receivers with detections. Depending on your data, these might need to be modified to encompass the deployment location of the tags, if tags were not deployed near towers with detections. We then use ggplot to plot the map and tag paths.  Here we use the Mercator projection and are colouring the paths by motusTagID, including a point for where the tag was deployed

```{r mapDetections}

# set limits to map based on locations of detections, ensuring they include the deployment locations
xmin <- min(df.alltags.filt.path$recvLon, na.rm = TRUE) - 2
xmax <- max(df.alltags.filt.path$recvLon, na.rm = TRUE) + 2
ymin <- min(df.alltags.filt.path$recvLat, na.rm = TRUE) - 2
ymax <- max(df.alltags.filt.path$recvLat, na.rm = TRUE) + 2
                
# map
ggplot(na.lakes, aes(long, lat))+ 
  geom_polygon(data = na.map, aes(long, lat, group=group), colour = "grey", fill="grey98")+#
  geom_polygon(aes(group = group), colour = "grey", fill = "white")+
  coord_map(projection="mercator", xlim = c(xmin, xmax), ylim = c(ymin, ymax))+
  xlab("") + ylab("") + 
  theme_bw() + 
  geom_path(data = df.alltags.filt.path, aes(recvLon, recvLat, group = "motusTagID", colour = as.factor(motusTagID))) +
  geom_point(data = df.alltags.filt.path, aes(tagDeployLon, tagDeployLat), colour = "black", shape = 4) +
  scale_colour_discrete("motusTagID") +
  facet_wrap(~speciesEN, nrow = 2)

```


