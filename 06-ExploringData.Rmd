# Exploring data with the Motus R package {#exploreData}

Once you have clarified any possible ambiguous tags, and removed false positives, you are ready to start analyzing your clean data set.  This chapter will walk you through some simple procedures to start working with and visualizing the clean sample data set, you can modify these scripts to work with your data.

## Load required packages

Follow the instructions in Chapter \@ref(loadingPackages) to install the following packages before loading, if you haven't already done so.

```{r loadpackages.6, message = FALSE, warning = FALSE}

library(motus)

```

## Load data

If you followed along with the the previous \@ref(dataCleaning) chapter and are working with cleaned sql.filtered file, you can skip ahead to \@ref(dataSummaries).  Otherwise we will load the sample data and clean it now.  Recall from \@ref(accessingData) that when accessing the sample database, you will need to input "motus.sample" as both username and password when prompted by the tagme() user authentication process. 

```{r importData}

proj.num <- 176

# load detection data
sql.motus <- tagme(proj.num)
tbl.alltags <- tbl(sql.motus, "alltags")
tmp <- tbl.alltags %>% collect() %>%
                as.data.frame() %>%
                mutate(ts = as_datetime(ts)) # work with dates AFTER transforming to flat file
```

## Remove false positives and ambiguous detections
```{r overwriteFilter}

sql.filtered <- applyRunsFilter(sql.motus, "filtAmbigFalsePos", p.min = 0.1)

```

## Summarizing your data {#dataSummaries}
You can see a quick summary of all variables in a data frame with the summary() function, here we'll just examine a few select variables:
```{r summaryAllTags}

sql.motus %>% tbl("alltags") %>% select(ts, motusTagID, runLen, speciesEN, tagDepLat, tagDepLon, recvDeployLat, recvDeployLon) %>% summary()
```

The dplyr package allows you to easily summarize data by group, manipulate variables, or create new variables based on your data.  

We can manipulate existing variables or create new ones with dplyr's mutate function, here we'll convert ts to a POSIXct format, then make a new variable for year and day of year (doy):
```{r tagMutate}

tmp <- tmp %>%
  mutate(ts = as_datetime(ts, tz = "UTC"), ## convert ts to POSIXct format
             year = year(ts), ## extract year from ts
             doy = yday(ts)) ## extract numeric day of year from ts
head(tmp)

```

We can also summarize information by tag by first grouping the data by motusTagID. Then we can apply various functions to these groups such as getting the total number of detections (n) for each tag, the number of receivers each tag was detected on, the first and last detection date, and the total number of days there was at least one detection:
```{r tagSummary}

tagSummary <- tmp %>%
  group_by(motusTagID) %>% 
  summarize(nDet = n(),
            nRecv = length(unique(recvDepName)),
            tsMin = min(ts),
            tsMax = max(ts),
            totDay = length(unique(doy)))
head(tagSummary)

```

We can also group by multiple variables, applying the same function as above but now grouping by motusTagID and recvDepName, we will get information for each tag detected on each receiver. Since we've specified to group by recvDepName, there will be by default only one recvDepName in each group, thus the variable nRecv will be 1 for each row which is not very information, however we've kept this variable in to help illustrate how grouping works:
```{r tagRecvSum}

tagRecvSummary <- tmp %>%
  group_by(motusTagID, recvDepName) %>% 
  summarize(nDet = n(),
            nRecv = length(unique(recvDepName)),
            tsMin = min(ts),
            tsMax = max(ts),
            totDay = length(unique(doy)))
head(tagRecvSummary)

```

## Plotting your data {#dataPlotting}
Plotting your data is a powerful way to visualize broad and fine-scale detection patterns, this section will give you a brief intro into plotting using ggplot2.  For more in depth information on the uses of ggplot2 we recommend the Cookbook for R <http://www.cookbook-r.com/Graphs/>, and the rstudio ggplot2 cheatsheet <https://www.rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf>.  

To make coarse-scale plots with large files we suggest first rounding the detection time to the nearest hour or day so that processing time is faster.  Here we'll round detection times to the nearest hour and work with that rounded dataframe, then we'll make a basic plot of hourly detection by motusTagID:

```{r}
tmp$hour <- as.POSIXct(round(tmp$ts, "hour"))
round.tmp <- tmp %>% select(motusTagID, port, mfgID, tagDepLat, tagDepLon, recvDeployLat, recvDeployLon, recvDepName, antBearing, speciesEN, year, doy, hour) %>% unique()

ggplot(data = round.tmp, aes(hour, as.factor(motusTagID))) + geom_point()
```
Let's focus only on tags deployed in 2016, we can also clean up the plot by removing the grey background, and we can colour the tags by species:
```{r}
ggplot(data = filter(round.tmp, round(tagDeployStart, "year") == 2016), aes(hour, as.factor(motusTagID), col = recvDepName)) +
  geom_point() +
  theme_bw()
```

We can see how tags moved latitudinally:
```{r}
ggplot(data = filter(round.tmp, round(tagDeployStart, "year") == 2016), aes(hour, recvDeployLat, col = as.factor(motusTagID), group = as.factor(motusTagID))) +
  geom_point() +
  geom_path()
  theme_bw()
```

Now lets look at more detailed plots of signal variation, here we'll use the full tmp dataframe so we can get signal strength for each detection of a specific tag.  Let's examine fall 2015 detections of tag 16039, we can facet the plot by deployment name, ordered by decreasing latitude.

```{r}
tmp <- within(tmp, recvDepName <- reorder(recvDepName, (-recvDeployLat))) ## order sitelat by latitude
ggplot(filter(tmp, motusTagID == 16039 & ts < as.POSIXct("2015-10-15")), aes(ts, sig)) + theme_bw() + geom_point() + facet_grid(recvDepName~.)
```
We can zoom in on certain time periods, for example the last detection and departure from the tagging location
```{r}
#NEED CODE
```

We can zoom in on a section of this plot and look at antenna bearings to see directional movement past stations:
```{r}
ggplot(filter(tmp, motusTagID == 16039 & ts > as.POSIXct("2015-09-14") &ts < as.POSIXct("2015-10-01")), aes(ts, sig, col = as.factor(antBearing))) + theme_bw() + geom_point() + facet_grid(recvDepName~.)
```

We can use the sunRiseSet function available in the motus R package (see \@ref(sunRiseSet)) to get sunrise and sunset times for all detections, we can then add that information to the above plot with geom_vline()
```{r}
tmp <- sunRiseSet(tmp)
ggplot(filter(tmp, motusTagID == 22897 & ts > as.POSIXct("2016-10-01") &ts < as.POSIXct("2016-10-29") & recvDepName == "Niapiskau"), aes(ts, sig)) + theme_bw() + geom_point() + geom_vline(xintercept = tmp$sunrise, col = "orange") + geom_vline(xintercept = tmp$sunset, col = "blue")
```

## Mapping your data {#mappingData}
To generate maps of tag paths, we will once again use summarized data so we can work with a much smaller database for faster processing, here we'll summarize detections by day:
```{r plotTagPaths.6}
tmp.path <- tmp.sub %>%
                    filter(tagProjID == proj.num) %>% # keep to tags registered to the sample project
                    arrange(motusTagID, ts) %>%       # order data by time stamp for each motus tag ID
                    mutate(date = as_date(ts)) %>%    # create date variable
                    group_by(motusTagID, date, recvDepName, ambigID, tagDepLon, tagDepLat, recvLat, recvLon)
```
### Mapping with Google Maps {#googleMaps}
Mapping with Google Maps can be a fast way to view flight paths that allows you to select from multiple base layers.  
For Google Maps, we'll need to load ggmap and ggplot2 packages, see \@ref(loadingPackages) for instructions on installing the package if you have no already done so.
```{r installGoogleMapPackages, message = FALSE, warning = FALSE, eval = FALSE}
require(ggmap)
require(ggplot2)
```
The first step is creating a map with a specified map centre, maptype ("terrain", "roadmap", "satellite", or "hybrid"), and level of zoom (integer for zoom 3-21, 3 being continent level, 10 being city-scale).  We then add points for receivers and lines connecting consecutive detections by motusTagID.
```{r}
gmap <-  get_map(location = c(lon = lonCentre, lat = latCentre), ## lon/lat to centre map over
                 maptype = "satellite", ## select maptype
                 source = "google",
                 zoom = 3) ## zoom, must be a whole number
  p <- ggmap(gmap)
  p + geom_point(data = tmp.path, aes(recvDeployLon, recvDeployLat), pch=21, colour = "black", fill = "yellow") +
    geom_path(data=data, aes(recvDeployLon, recvDeployLat, group=fullID, col = fullID)) +
    theme_bw()
```

### Creating simple outline maps {#outlineMaps}
For mapping with outline maps, we'll need to load the rworldmap package, see \@ref(loadingPackages) for instructions on installing the package if you have no already done so.
```{r installMapPackages, message = FALSE, warning = FALSE, eval = FALSE}
require(rworldmap)
```

Now we need to load the base maps

```{r loadMaps.6, message = FALSE, warning = FALSE}

na.lakes <- map_data(map = "lakes")
na.lakes <- mutate(na.lakes, long = long- 360)

# Include all of the Americas to begin
na.map <- subset(map_data(map="world2"), 
                 region %in% c("Canada", "USA", "Mexico", "lakes",
                               "Belize", "Costa Rica", "Panama", 
                               "Guatemala", "Honduras", "Nicaragua", 
                               "El Salvador", "Colombia", "Venezuela", "Ecuador", "Peru", "Brazil",
                               "Guyana","Suriname", "Bolivia", "French Guiana", "Jamaica", "Cuba", 
                               "Haiti", "Dominican Republic", "The Bahamas", "Turks and Caicos Islands", 
                               "Puerto Rico", "British Virgin Islands", "Montserrat", "Dominica", "Saint Lucia", "Barbados", "Grenada", "Trinidad and Tobago", "Chile", "Argentina", "Uruguay", "Paraguay"))

na.map <- mutate(na.map, long = long- 360)

```

Finally, to map the paths, we set the x-axis and y-axis limits based on the location of receivers with detections. Depending on your data, these might need to be modified to encompass the deployment location of the tags, if tags were not deployed near towers with detections. We then use ggplot to plot the map and tag paths.  Here we use the Mercator projection and are colouring the paths by motusTagID, including a point for where the tag was deployed

```{r mapDetections}

# set limits to map based on locations of detections, ensuring they include the deployment locations
xmin <- min(tmp.path$recvLon, na.rm = TRUE) - 2
xmax <- max(tmp.path$recvLon, na.rm = TRUE) + 2
ymin <- min(tmp.path$recvLat, na.rm = TRUE) - 2
ymax <- max(tmp.path$recvLat, na.rm = TRUE) + 2
                
# map
ggplot(na.lakes, aes(long, lat))+ 
  geom_polygon(data = na.map, aes(long, lat, group=group), colour = "grey", fill="grey98")+#
  geom_polygon(aes(group = group), colour = "grey", fill = "white")+
  coord_map(projection="mercator", xlim = c(xmin, xmax), ylim = c(ymin, ymax))+
  xlab("") + ylab("") + 
  theme_bw() + 
  geom_path(data = tmp.path, aes(recvLon, recvLat, group = motusTagID), colour = as.factor(motusTagID)) + 
  geom_point(data = tmp.path, aes(tagDepLon, tagDepLat), colour = "black", shape = 4) +
  scale_colour_discrete("motusTagID") +
  facet_wrap(~motusTagID, nrow = 2)

```



