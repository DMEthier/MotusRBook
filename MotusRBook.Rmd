---
title: "R for Motus"
author: "Tara L. Crewe and Zoe Crysler"
date: "`r Sys.Date()`"
output: bookdown::gitbook
documentclass: book
site: bookdown::bookdown_site
cover-image: BSC_Motus_Logo.png

---

# A walk through the use of R for Motus automated radio-telemetry data  {-}

```{r coverimage, echo=FALSE, out.width="700px", fig.align='center'}
knitr::include_graphics("images/MotusBSCLogo.png")
```

Our goal with this online 'handbook' is to show Motus (<https://motus.org>) users how to use the Motus R package (<https://github.com/jbrzusto/motus>), along with other stand-alone R packages (e.g., ggplot2), to import tag detection data for their project or receiver; explore their data through visualizations and summaries; transform their data, e.g., by determining time since sunrise/sunset or magnetic declination; and to run various analytical procedures. This book therefore goes beyond simply highlighting the functionalities of the Motus R package - it also shows users, who may not be experts in R, to use additional R packages to do basic summaries and plots. We hope the contents will be of use, and if you have suggestions for additional examples, please let us know by emailing motus@birdscanada.org. 




<!--chapter:end:index.Rmd-->



# Introduction {#introduction}
```{r fig1, echo=FALSE}
knitr::include_graphics("images/Motus-System-IG-final.png")
```
 <br>
The Motus Wildlife Tracking System ('Motus'; Taylor et al. 2017; <https://www.motus.org>) is an international, collaborative automated radio-telemetry network that is used to track the movement and behaviour of primarily small flying organisms affixed with digitally encoded radio-transmitters.  Motus has its roots in the SensorGnome network piloted in 2012-2013. In 2014, a major infrastructure expansion was made possible through a Canada Foundation for Innovation grant to Western University, The University of Guelph, and Acadia University.  Since then, Motus has continued to grow through the collaboration of independent researchers and organizations <https://motus.org/about/>, and is now managed as a program of Bird Studies Canada (<https://www.birdscanada.org>) in partnership with Acadia University. 

Motus is unique among automated telemetry arrays in that all researchers in a geographic region (e.g., the Americas or Europe) use a shared radio frequency. This allows tagged animals to be detected by any receiving station across the network, greatly broadening the spatial scope of potential research questions.  Motus users also use a shared data infrastructure and web portal: all data collected from across the network are centrally stored and archived, which allows users to access detections of their tags by anyone's receiver in the network, and individuals that maintain receivers have access to all detections of anyone's tags on those receivers.

Having a shared data infrastructure also means that users can benefit from R functions written specifically for Motus data by any and all users. A Motus R package is in continual development, and the intent of this online 'handbook' is to help users learn how the various functionalities of the package, and additional R packages like ggplot, can be used to retrieve tag detections, explore, visualize, transform, and analyze Motus data. The content of the handbook will continue to evolve and grow along with the analytical needs of the network. Those interested in contributing code to the Motus R package or this handbook can send proposed additions to Tara Crewe (tcrewe@birdscanada.org) or Zoe Crysler (zcrysler@birdscanada.org) (??).  

Taylor, P. D., T. L. Crewe, S. A. Mackenzie, D. Lepage, Y. Aubry, Z. Crysler, G. Finney, C. M. Francis, C. G. Guglielmo, D. J. Hamilton, R. L. Holberton, P. H. Loring, G. W. Mitchell, D. R. Noriis, J. Paquet, R. A. Ronconi, J. Smetzer, P. A. Smith, L. J. Welch, and B. K. Woodworth. 2017. The Motus Wildlife Tracking System: a collaborative research network to enhance the understanding of wildlife movement. Avian Conservation and Ecology 12(1):8. https://doi.org/10.5751/ACE-00953-120108.

## What this book does not cover {#whatBookCovers}

This book does not currently cover how to register radio tags with Motus, manage tags and station deployments, upload data, and so on. Information to guide you through those tasks can be found under the 'resources' tab on the Motus website at <https://motus.org/resources/>.  Please remember to register your tags and enter tag and station metadata with Motus prior to deploying your tags. Please also see <https://motus.org/policy/> to review our collaboration policy and tag registration and fee schedule.

## Prerequisites {#prerequisites}

This book assumes that you have a basic understanding of R. If you are new to R, we highly recommend 'R for Data Science' by Garrett Grolemund and Hadley Wickham (<http://r4ds.had.co.nz/>), which covers how to import, visualize, and summarize data in R using the Tidyverse collection of R packages <https://www.tidyverse.org/>. It also provides useful tips for organizing your workflow to create clean, reproducible code (<http://r4ds.had.co.nz/workflow-projects.html>). We follow their lead by using Tidyverse throughout this book, and where possible within the package functions.

## How this book is organized {#bookOrganization}

Each section of this book will begin with a paragraph or figure describing the broader intention or outcome of the section, followed by details on how to get there using R. For example, the section on accessing and downloading tag detection data begins with a screenshot of the structure of a dataframe, followed by the R code required to access the data.

## Sample dataset {#sampleData}

Throughout this book we use a subset of data from the James Bay Shorebird Project to illustrate how to access, manage, and analyze Motus data in R. The James Bay Shorebird Project conducts monitoring and research on shorebirds staging along the James Bay coast, and is a collaborative effort among the Ontario Ministry of Natural Resources and Forestry, Bird Studies Canada, Trent University, and Environment and Climate Change Canada's Canadian Wildlife Service, in conjunction with a larger conservation initiative involving James Bay first nations and Nature Canada. The Royal Ontario Museum was a contributing partner until 2016. The goals of the project are to 1) improve the ability to estimate indices of abundance and population trends for shorebird species staging along the western James Bay coast, 2) understand movement patterns and their causes, and 3) identify the relative importance of shorebird staging sites and their habitats. Collectively, this information will aid in the development of conservation measures for Red Knot and other shorebird species through habitat protection like Western Hemisphere Shorebird Reserve Network (WHSRN) designation. More information can be viewed on the James Bay Shorebird Project website at <https://www.jamesbayshorebirdproject.com/>, on Facebook <https://www.facebook.com/jamesbayshorebirdproject/>, or by contacting their project lead:

Christian Friis
Wildlife Biologist
Canadian Wildlife Service Environment and Climate Change Canada / Government of Canada 
christian.friis@canada.ca / Tel: 416.739.4908
 
biologiste de la faune  
Service canadien de la faune Environnement et Changement Climatique Canada / Gouvernement du Canada 
christian.friis@canada.ca / TÃ©l. : 416.739.4908 

The sample dataset can be downloaded as a .zip file at: <https://motus.org/>, and once the .motus file is extracted, can be loaded into R using the following:

```{r importSampleDF}

file.name <- "./data/sampledb.motus"    ## replace with the full location of the extracted .motus file on your personal computer
t <- dplyr::src_sqlite(file.name)

```

## Acknowledgements {#acknowledgements}

Some of the text included in this book was adapted from John Brzustowski's github repository for the Motus R package at: <https://github.com/jbrzusto/motus>.

Motus was conceived as the SensorGnome network by Philip Taylor and John Brzustowski at Acadia University. Initial expansion of the network was supported by a Canada Foundation for Innovation Grant to Western University (Christopher Guglielmo), The University of Guelph (D. Ryan Norris), and Acadia University (Philip Taylor). The development of the Motus web interface, R package, and accompanying handbook were made possible through a Canarie grant to Bird Studies Canada (<https://www.canarie.ca/>). Motus continues to grow as a program of Bird Studies Canada, through the collaboration of numerous independent researchers, organizations, and individuals. A non-exhaustive list of Motus partners and collaborators can be found at <https://motus.org/data/partners.jsp>. If your organization is not listed, please contact motus@birdscanada.org.

Many people have worked together to bring Motus technology, the web interface, and R-package together. The core 'Motus Team' includes John Brzustowski, Zoe Crysler, Tara Crewe, Jeremy Hussell, Catherine Jardine, Denis Lepage, Stuart Mackenzie, Paul Morrill, and Philip Taylor. 


<!--chapter:end:01-Introduction.Rmd-->

# Loading R Packages {#loadingPackages}

There are two R packages available to Motus users:

1. motusClient: provides functions to download and update detections data and tag and receiver deployment metadata from the Motus server.

2. motus: provides functions to output summary plots, and to transform (add sun rise/sun set times), and analyze Motus data.

Motus **users** can install the latest stable versions of the R packages using the following code. You only need to install the packages once, but once installed, you do need to load each package (using library() or require()) each time you open a new R session. 

Please note that some functionalities of the devtools package may require updated versions of R and RStudio. To avoid errors, please ensure you are using the most recent releases of R (<https://www.r-project.org/>) and RStudio (<https://www.rstudio.com/products/RStudio/>), and update your R packages using update.pacakges() in the R console.


```{r update packages, eval = FALSE}
update.packages()                         ## to update your existing R packages
```

```{r install packages, eval = FALSE}
install.packages("devtools")              ## if you haven't already done this
library(devtools)                         ## load devtools

# install motusClient for data download
install_github("jbrzusto/motusClient@master")   ## the last stable version
library(motusClient)

# install motus for data manipulation, visualization and analysis
install_github("jbrzusto/motus@testbuild1")   ## the last stable version
library(motus)
```


For **developers**, the 'staging' branch is for work-in-progress. Install it with:

```{r install packages developer, eval = FALSE}   
install.packages("devtools")               ## if you haven't already done this
library(devtools) 

install_github("jbrzusto/motus@staging")   ## the development version
library(motus)
```

Throughout the book, we use Tidyverse (<https://www.tidyverse.org/>), which is a collection of R packages for data science, including tidyr, dplyr, and ggplot2, and lubridate for managing and manipulating dates. These can be installed with:

```{r install tidyverse, eval = FALSE}
install.packages("tidyverse")             ## again, you only need to install once.
library(tidyverse)

install.packages("lubridate")            
library(lubridate)

```

More information on Tidyverse can be found at <https://www.tidyverse.org/>, or by browsing 'R for Data Science' by Garrett Grolemund and Hadley Wickham: <http://r4ds.had.co.nz/>.

## User Authentication {#userAuthentication}

The first time you call a function using the Motus R package, you will be asked for your motus.org username and password to authenticate your access to project data. This will only happen once per R session. If you do not have a Motus user name and password, you can sign up at <https://motus.org/data/user/new>. Permission to access project data will then be granted by Motus staff or the project principal investigator.

## Internal data processing {#internalProcessing}

As an animal moves within the detection range of a Motus station, radio transmissions, or 'bursts', are detected by antenna(s) and recorded by a receiver. These raw detection data are either uploaded to the Motus database instantaneously via internet connection, or downloaded from the receiver and uploaded to Motus manually. Behind the scenes, various functions read and process the raw detections data to produce the tag detections file that users access using the R package (see 'Data Import' below). While most users will not need to call on the internal data processing functions, a complete list of functions within the Motus server R package can be found on GitHub: <https://github.com/jbrzusto/motusServer>. The code behind each function can be viewed on GitHub, or by typing the following in the R console after loading the R package, replacing 'function.name' with the name of the R function of interest:

```{r function.name, eval = FALSE}
function.name() 
```


<!--chapter:end:02-LoadingPackage.Rmd-->

# Accessing and understanding detections data {#accessingData}

It is important to note that the success of the Motus network is dependent on the timely upload of detection data from receivers, and on the maintenance of accurate and up to date tag and receiver metadata by collaborators.  Users are encouraged to check for updated detection data and metadata each time they run an analysis, because collaborators can add detection data and metadata at any time, and these could influence the completeness of your own detections data.

## Database types {#databaseTypes}

```{r fig3, echo = FALSE}

knitr::include_graphics("images/DataStructure.png")

```

<br>

There are two types of tag databases:

1. **receiver database**: includes all detections of any registered tags from a single receiver. A receiver database has a name like SG-1234BBBK5678.motus; where the name is the serial number of the receiver.

2. **project database**: includes all detections of your registered tags from across the motus network. A tag project database has a name like project-123.motus, where the number is the motus project ID.


These two databases correspond to the basic model of data sharing:

1. you get all detections of anyone's tags by *your* receivers (i.e., one receiver tag database for each receiver you deploy)

2. you get all detections of *your* tags by *anyone's* receivers (i.e., one project tag database for each of your motus projects)

## Load relevant R packages {#loadPackages}

```{r loadPackages, warning = FALSE, message = FALSE}

require(devtools)
require(tidyverse)

```

## Importing tag detections {#importDetections}

Your project's .motus file is available for download at <https://motus.org/data/downloads> under your project profile. Once downloaded, **make sure that you have the appropriate packages installed and loaded in R** (see Chapter \@ref(loadingPackages). 

Once all required packages are loaded, you can use the following code to load your project data, or the sample data from the James Bay Shorebird Project ('sampledb.motus'; see Section \@ref(sampleData)):

```{r import, message = FALSE}

file.name <- "./data/project-sample.motus"    ## replace with the full location of the sample dataset or your own project-XX.motus file
t <- dplyr::src_sqlite(file.name)

```

## Data structure {#databaseStructure}

Your tag database is stored as an SQLite ('dplyr::src_sqlite') file with the extension '.motus'. The sqlite format was chosen because:

1. it is flexible, allowing for many data formats.
2. it is accessible from many software platforms (not just R).
3. it is **appendable**: the database can be created and updated on disk without having to read in and resave the entire contents. This will save time and computer memory when searching to see if any new detections are available for your project or receiver.

The .motus file contains a series of interelated tables where data are stored in a condensed format to save memory. The following tables are included in the .motus file; a complete list of parameters stored in each table can be found in Appendix Table A1:

1. hits: detections data at the level of individual hits.
2. runs: detections data associated with a run (continuous detections of a unique tag on a given receiver).
3. batches: detections data for a given receiver and boot number.
4. batchRuns:
5. projBatch:
5. meta:
6. tags: metadata related to tags, e.g., unique identifier, tag characteristics (e.g., burst interval).
7. tagAmbig
8. tagDeps: metadata related to tag deployments, e.g., deployment date, location, and species.
9. recvs:
10. recvDeps: metadata related to receiver deployments, e.g., deployment date, location, receiver characteristics.
11. antDeps: metadata related to antenna deployments, e.g., deployment height, angle, antenna type.
12. species: metadata related to species, e.g., unique identifier, scientific name, common name.
13. projs: metadata related to projects, e.g., project name, principal investigator.
14. gps: metadata related to Geographic Positioning System (GPS) position of receiver. 
15. projAmbig: 

In addition to these tables, we have created some 'virtual' tables, which are queries which combine data from the various tables into a single convenient 'view' that contains all of the fields you are likely to need. The following views are currently included in your .motus file:

1. alltags
2. allambigs
3. alltagswithambigs


Because the file is a dplyr::src_sqlite file, all of the dplyr functions can be used to filter and summarize your .motus database, without needing to first save the data as a *flat* file, i.e., a typical two-dimensional dataframe with every record for each field filled in. 

You can access each table in the .motus file using the tbl() function, for example:

```{r getTable, message = FALSE}

# tag deployment metadata
tagMeta <- tbl(t, "tagDeps")
head(tagMeta)           
tagMeta$ops$vars        

```

If you look at the underlying structure of these tables using str(), you will see that each is a list of length 2:

```{r dfStructure}

str(tagMeta)

```

The first part of the list, 'src', is a list that provides details of the SQLiteConnection, which includes information on where the database is stored. The second part of the list, 'ops', is also a list, and includes the names of the variables ('tagMeta$ops$vars') included in the  table. In other words, in its current form, the R object 'tagMeta' does not hold the data itself (i.e., it is a *virtual* table); rather, it includes the database structure and information required to connect to the underlying data in the .motus file. As stated above, the advantage of storing the data in this way is that it saves memory when accessing very large databases, and the dplyr package can be used to manipulate and summarize the tables before collecting the results into a typical "flat" format dataframe.

For your convienience, the *virtual* table 'alltags' contains all fields that most users will need from the various .motus tables, and can also be accessed using the dplyr tbl() function:  

```{r getAllTagsTable}

df <- tbl(t, "alltags")

```

The following table lists the parameters available in the 'alltags' table, along with a description of each parameter.

```{r parameterTable, echo = FALSE}

param.table <- dplyr::select(read.csv("./data/DatabaseParameters.csv"), 1:2)
knitr::kable(param.table, caption = "Description of fields in the tag detections database") 

```

### Convert a virtual table to a flat dataframe {#convertToFlat}

If you want your entire dataframe in a typical "flat" format, i.e., with every record for each field filled in, you can use the collect() function.  The output can then be used to generate a .rds or .csv file of your data. However, we caution that producing such a table using the full suite of fields can chew up a lot of memory, and can slow R down considerably when dealing with large datasets:

```{r collect}

df.flat <- df %>% collect %>% as.data.frame      ## for all fields in the df

```

```{r quickLook}

names(df.flat)     ## field names
str(df.flat)       ## Look at the structure of your data fields
head(df.flat)      ## Look at first 6 rows of your df
summary(df.flat)   ## summary of each column in your df

```

If you want to load only part of your entire data frame (eg. certain fields, only certain tags, all tags from a specified project, species, etc.), you can use dplyr funtions to filter the data before collecting into a flat dataframe.  Some examples are below:

1. To select certain fields:
```{r collect1, eval = FALSE}

df.flat.subset <- select(df, recv, ant, motusTagID) %>% distinct %>% collect %>% as.data.frame      ## to grab a subset of fields, in this case a unique list of motus tag IDs at each receiver and antenna.

```

2. To select certain tag IDs:
```{r collect2, eval = FALSE}

df.flat.subset <- filter(df, motusTagID %in% c(9939, 25643)) %>% collect %>% as.data.frame    ## filter to only include detections of motus tag IDs 9939 and 25643

```

3. To select a specified species:
```{r collect3, eval = FALSE}

df.flat.subset <- filter(df, speciesID == 15580) %>% collect %>% as.data.frame    ## filter to only include detections of Swainson's Thrush by species ID
df.flat.subset <- filter(df, spEN == "Swainson's Thrush") %>% collect %>% as.data.frame    ## filter to only include detections of Swainson's Thrush by English name

```

You can also summarize your data before converting to a flat file. For example, to find the first hourly detection of each tag in each hour by receiver and antenna, you could do this:

```{r collectSum, eval = FALSE}

hourly <- df %>% mutate (hour = 3600 * round(ts / 3600, 0)) %>% distinct (recv, ant, motusTagID, hour)

## and collect these into a data.frame

hh <- hourly %>% collect %>% as.data.frame
```

### Export your "flat" dataframe to a .csv file {#exportToCSV}

The below example is how you would save the flat file called "df.flat" within R, as a .csv file called "JB_raw.csv" on your computer in the 'data' folder of your working directory. In this case, JB stands for James Bay, and we are simply converting the data without subsetting.

```{r createFlat, eval = FALSE, message = FALSE, warning = FALSE}

write.csv(df.flat, "./data/JB_raw.csv")  ## "df.flat"" is the name of the flat file within R that you want to convert to a .csv
## "./data/" is the the location where you would like your .csv stored
## "JB_raw.csv", is the name of the .csv file you are creating, this can be anything you like but must end with .csv.

```

<!--chapter:end:03-AccessingData.Rmd-->

# Duplicate tags and ambiguous detections {#ambiguities}

Duplicate tags occur when there are two or more tags with the same Lotek ID code, burst interval, and nominal transmit frequency (i.e., tags are indistinguishable). 

The tag finder program only looks for tags in the raw detections data during their active lifetimes. Tag lifetimes are estimated based on tag metadata, including deployment date, tag model, and burst interval. If duplicate tags do not overlap in their active lifetimes, there is no ambiguity in terms of which project and tag the detections belong to, and each detection is assigned unambiguously to the correct project and tag. This is by far the most common situation for duplicate tags in the Motus system. 

In the rarer situation when duplicate tags are deployed with overlapping lifetimes, this can result in ambiguous tag detections, where more than one tag (up to 6) could be the source of those detections. The ambiguities might be real if two or more tags are transmitting the same signal and active at the same time, or due to errors in tag registration or deployment metadata. If there are ambiguities in your data, please ensure that your tag metadata are complete, up-to-date, and accurate. 

## Load required packages

If you have not already installed the following packages, please follow the instructions in Chapter \@ref(loadingPackages).

```{r loadpackages}

library(devtools)
library(motusClient) # package to communicate with Motus server and grab project data
library(motus)   
library(tidyverse)
library(lubridate)

```

## Check for ambiguous tags in detections data {#checkAmbigs}

In your detections data, ambiguous detections are identified by a unique negative value in the 'motusTagID' field. As a first step, We will load our data into R, and check for negative motusTagIDs. You can follow along using the example dataset we provide, which is a subset of data from the James Bay Shorebird Monitoring Project (see Section \@ref(sampleData)), or you can replace the project number with your own, and follow along using your own data.

```{r importdata}

file.name <- "./data/project-sample.motus"    ## or replace with the full location of your 'project-XX.motus' data
t <- dplyr::src_sqlite(file.name)
df <- tbl(t, "alltags")

# list of motusTagIDs in detections data

tags <- select(df, motusTagID) %>% distinct() %>% arrange(motusTagID) %>% collect( )%>% as.data.frame()

filter(tags, motusTagID < 0) %>% summarize(nAmbiguities = n())
filter(tags, motusTagID < 0) %>% as.list()

```

We see from the list of motusTagIDs that there are `nrow(filter(tags, motusTagID < 0) %>% distinct())` ambiguities in the data. Using the clarify() function from the motusClient R package, we can load a table which reports the ambigID, which corresponds to the negative motusTagID in the detections data, and will tell as what true motusTagIds these ambiguous detections could represent:

```{r clarify}

ambig <- clarify(t)
head(ambig)

```

In the ambig table, there are columns for up to 6 true motusTagIDs that the ambigID might correspond to. Using the summary() function, we can see how many of these ID columns are relevant to our situation. In this case, id4 through id6 contain all NAs, which means that at most we have ambiguitied with three possible tags:

```{r summClarify}

summary(ambig) # see that there is only data in id1 and id2 fields (no instances of > 2 identical tags)

```

For your convenience, we created two virtual tables, or views, of the ambiguous detections in the .motus files which can be used to summarize and visualize the ambiguous detections, and decide whether they are detections of your tags or the tags of others. The two views are:

1. "allambigs", which lists in long-data format each motusTagID associated with each ambigID.
2. "alltagswithambigs", which 

```{r loadAmbigViews, message = FALSE, warning = FALSE}

allAmbigs <-  tbl(t, "allambigs")

ambig.df <-  tbl(t, "alltagswithambigs")
ambig.df <- ambig.df %>% collect %>% as.data.frame  

```

To decide whether the ambiguous detections correspond to detections of your tags or those of others, we will first load the tag metadata from your .motus file. The tag metadata will include the unique 'motusTagID' and associated deployment information for all of your registered tags and any duplicate tags from other projects. Metadata for duplicate tags from other projects can be useful to show when and where those tags were deployed. We will plot this information with the tag detections to help tease apart whether the ambiguous detections are likely to be from your tag(s) or those of others.

After we load the metadata, we will transform it from a sqlite table to a flat file to more easily maniplulate dates, which are stored in the .motus file as seconds since Jan 01 1970.

```{r importTagMeta}

tagMeta <- tbl(t, "tagDeps")
tagMeta <- select(tagMeta, projectID, deployID, tagID, tsStart, tsEnd, speciesID, latitude, longitude) %>% 
  distinct() %>%
  collect() %>% 
  as.data.frame()

# manipulate dates using the lubridate() package

tagMeta <- mutate(tagMeta, 
                  dtStart = as_datetime(tsStart, tz = "UTC"),
                  yrStart = year(dtStart),
                  dmyStart = date(dtStart),
                  dtEnd = as_datetime(tsEnd, tz = "UTC"),
                  yrEnd = year(dtEnd),
                  dmyEnd = date(dtEnd))

head(tagMeta)
```

We then make a list of tags from the .motus file that also occur in the metadata. We will then transpose and subset the ambiguous detections table to include only those motusTagIDs that are registered to our project. These will be used to merge with the detections data, to assign a true motusTagID to the negative motusTagIDs of ambiguous detections.  To do this, we transform the detections data to a flat file, but selecting only a few variables of interest to save on memory. Remember to replace the listed project ID (38) with your own when using your own project data:

```{r taglist}

# list of tags registered to the James Bay Shorebird Project (projectID 38)

tag.list <- filter(tagMeta, projectID == 38) %>% select(tagID) %>% distinct() 

# transpose the ambiguous detections table

t.ambig <- gather(select(ambig, ambigID, id1, id2, id3, id4, id5, id6), key = id, value = motusTagID2, -ambigID) %>%
  filter(!is.na(motusTagID2)) %>% select(-id) %>% arrange(ambigID)

# filter the list of ambiguities to include only the ambig IDs corresponding to your own tags.

t.ambig <- filter(t.ambig, motusTagID2 %in% tag.list$tagID)

# First create a flat file of the detections data, then do a full merge, so that if there are any instances where your own tags are duplicates, the detections data will be plotted for both.

detect.df <- select(df, hitID, ts, sig, motusTagID, ant, runLen, tagProjID, id, speciesID, lat, lon, site, projID, tagProj, depLat, depLon) %>% collect() %>% as.data.frame()

detect.df2 <- full_join(detect.df, t.ambig, by = c("motusTagID" = "ambigID")) %>% filter(!is.na(motusTagID2))

```

In project 38, there are `r length(tag.list$tagID)` registered tags.

```{r transpose} 
# first transpose the ambig table, so that for each negative motusTagID, you have a list of potential true motusTagIDs that this could refer to:

t.ambig <- gather(select(ambig, ambigID, id1, id2, id3, id4, id5, id6), key = id, value = motusTagID2, -ambigID) %>%
  filter(!is.na(motusTagID2)) %>% select(-id) %>% arrange(ambigID)

# now use this to do a full merge with 
# merge detections data with ambiguous tag ids. You'll end up with detections duplicated in the dataframe, so that for each tag that motusTagID -169 might refer to, those detections will be repeated for each motusTagID2 that corresponds to this ambiguity.  Can then plot the detections for each tag.

df <- full_join(df, tmp , by = "motusTagID")

```



<!--chapter:end:04-Ambiguities.Rmd-->

# Data Checking: Metadata {#checkMetadata}

Data quality for your projects and the projects of others depends on complete and accurate tag and receiver metadata. Complete metadata will allow detections to be properly linked to your project, and allow other users to benefit fully from data collected by the Motus network of receivers. Once you have imported your data using R, it is therefore good practice to run data summaries to check for missing or incorrect tag and receiver deployment metadata.

**Missing or incorrect tag metadata** can result in a lack of tag detections in your data. For example, if deployment date is missing or wrong, the tag finder, which processes the data from each receiver in the network, might not look for your tag in the data, or might not look at the appropriate time when the tag is actually active. This will result in missing tags in your detections data.

**Missing or incorrect receiver metadata** can result in a loss of information for both your project and the projects of other Motus users. For example, missing deployment latitude and longitude can result in a loss of information on the location of a receiver. Particularly when the same receiver is moved from one location to another, it is important your metadata reflect this, so that you and other users can properly analyze your/their data. Missing antenna deployments, including port number, height and orientation, can also limit what users can do with their data. For example, departure orientation cannot be estimated without the latitude, longitude, orientation, height, antenna type, and port of each antenna. If orientation isn't something you are interested in, please keep in mind that others with tags detected on your receivers might be. We therefore encourage you to enter *all* tower and antenna metadata, even if it may not seem relevant to your own project goals.

As you run through the following code to check your metadata, **please fix metadata errors or omissions** in your project by signing in to <https://motus.org/>, and under the 'Manage Data' tab, select either 'Manage Tags' to fix tag deployment metadata or 'Manage Receivers' to fix receiver deployment metadata. It is important to fix metadata errors online, so that errors are fixed at the source, are archived on the Motus Server, and to ensure all users have access to the correct tag and receiver metadata.

## Load relevant R packages

```{r loadPackages.4, warning = FALSE, message = FALSE}

require(devtools)
require(tidyverse)

```

## Tag Metadata {#tagMetadata}

### Import Data {#importTagMeta}

We will import both the tag metadata, to check which tags are registered to your project, and also the tag detections data, to compare which of the registered tags and present in your detections data.

#### Metadata

To import and convert your tag metadata in your .motus file to a flat file: 

```{r importTagMeta.4, message = FALSE, warning = FALSE}

t <- dplyr::src_sqlite("./data/project-8.motus")      # import .motus file from your local directory (change directory to match)
tagMeta <- tbl(t, "tagDeps")                          # extract tagDeps table, with tag deployment metadata
tagMeta <- tagMeta %>% collect %>% as.data.frame      # convert tag metadata to a flat file

```

#### Detections Data

Instructions to access and convert your detections data into a flat file are available in Accessing Data chapter.  Here we import the resulting .csv file from a local directory.

```{r importDetections, message = FALSE, warning = FALSE}

df <- read.csv("./data/JB_raw.csv")

```

### Tag Metadata Checks {#tagMetadataChecks}

Only tags registered with Motus (<https://motus.org/tag-registration/>) prior to deployment will appear in detections data.


To view a full list of registered tags in your tag metadata:

```{r tagList, echo = FALSE}

select(tagMeta, tagID, deployID) %>% distinct()

```



***** might want to have a list of registered tags from metadata vs. list of tags in data




If previously registered tags are missing from your data, please contact motus@birdscanada.org

Required tag metadata includes deployment start date/time, end date/time if applicable, deployment latitude, deployment longitude, and species.  You can determine which of your tags are missing this metadata as follows:

**INSERT CODE**

Please update missing tag metadata online at <www.motus.org> by logging in to your project and selecting the 'Manage your tags' option.

### Receiver Metadata {#recvMetadata}

To obtain detection data from a receiver, it must be registered online to your project by it's serial number.  Receiver deployments are then required to link the appropriate metadata to each detection.  To determine a list of receivers registered to your project:

***INSERT CODE***

If you are missing any receivers, please register them online through your project management page

Each receiver requires a deployment which includes a deployment name, site, station type, deployment start/end dates/times, latitude, longitude, and antenna properties including port number, antenna type, and bearing. To view a full list of your current deployments:

***INSERT CODE***

To view which current deployments are missing required information:

***INSERT CODE***

Any missing receiver metadata needs to be updated online.

If you have updated any metadata online, you'll need to force an update on the data you have downloaded, it's good practice to check for updates prior to any analysis as other users may have updated metadata associated with your detection files:
```{r tagme5, eval = FALSE}
t <- tagme(projRecv = 123, forceMeta = TRUE)
```


<!--chapter:end:05-CheckingMetadata.Rmd-->

# Cleaning data to remove false detections {#dataCleaning}

Background radio noise will sometimes create false positives in your detection data. Some sites will inherently have more background noise than others, and some tag IDs are more prone to false positives than others. Once you download your data, the first step should be cleaning it of false detections. There are a few ways to do this, ultimately it is up to you to determine which detections are true and which should be removed. Below we outline a number of ways to determine if detections are likely false positives.

## Load relevant R packages

```{r loadPackages.5, warning = FALSE, message = FALSE}

library(devtools)
library(tidyverse)
library(motus)
library(lubridate)

```

## Removing detections outside of deployment range {#filterDeployRange}

A first step to removing definite false positives, is to remove any detections that fall outside of the tag deployment dates. To do this we will need to import the tagging metadata and merge it with the tag detection files to see tag deployment start/end dates.

1. **Download tag deployment metadata**: from the download page <https://motus.org/data/downloads>, select your project from the dropdown menu and click "Tag Deployments" to get a tag-deployments.csv file. Alternatively, you can download the same deployments file from your project tag page.

2. **Import tag deployment metadata into R**

```{r tagMeta, message = FALSE, warning = FALSE}

tagMeta <- read.csv("./data/tag-deployments-jb.csv") ## replace the location with the file path where you saved the .csv file.
## rename columns
tagMeta <- rename(tagMeta, motusTagID = tagID, tagStart = tsStart, tagEnd = tsEnd)

```

OR (we should probably go this way, and work from the .motus file) 

1-2. **Import tag deployment metadata from your .motus file**
To import and convert your tag metadata in your .motus file to a flat file (for more information see 'Accessing Data' chapter): 

```{r importTagMeta.5, eval = FALSE, message = FALSE, warning = FALSE}

#t <- dplyr::src_sqlite("./data/project-38.motus")     # import .motus file from your local directory (change directory to match)
#tagMeta <- tbl(t, "tagDeps")                          # extract tagDeps table, with tag deployment metadata
#tagMeta <- tagMeta %>% collect %>% as.data.frame      # convert tag metadata to a flat file

```

3. **Join tag metadata and detection data**: Once you've created a flat .csv file of your data (see 'Accessing Data' Chapter), you can import using the following statement:
```{r importDetectData, eval = FALSE, message = FALSE, warning = FALSE}

JBraw <- read.csv("./data/JB_sample_data_all.csv")

```
Join the tagMeta database to your detection data, here we only include the start/end date columns from the tagMeta database, however you can choose to keep all columns if necessary.
```{r mergeDepswithDet, eval = FALSE, message = FALSE, warnings = FALSE}

JBraw <- dplyr::left_join(JBraw, select(tagMeta, tagDeployID, motusTagID, tagStart, tagEnd))

```

4. **Remove detections that fall outside tag deployment dates**
```{r detectionsOutsideDep, eval = FALSE, message = FALSE, warning = FALSE}
## first ensure that all times are in POSIXct
JBraw$ts <- as_datetime(JBraw$ts, tz = "UTC")
JBraw$tagStart <- as_datetime(JBraw$tagStart, tz = "UTC")
JBraw$tagEnd <- as_datetime(JBraw$tagEnd, tz = "UTC")
## subset to keep anything within tag deployment range, making sure to account for NAs in end dates
JBraw <- subset(JBraw, ts < tagEnd | is.na(tagEnd))
JBraw <- subset(JBraw, ts > tagStart)
```

## Removing detections based on visual geographic positions {#filterGeoPosition}

A few simple plots of latitude/longitude vs. time can highlight detections that occur in areas outside of the expected geographic range of the species for that date, or flights showing impossible speeds over large distances.
First, lets replace any instances with no GPS coordinates with the given locations from receiver deployment metadata:
```{r replaceMissingCoords, eval = FALSE, message = FALSE, warning = FALSE}
## NEED TO ADD SCRIPT
## for now:
JBraw <- filter(JBraw, lat > 0)
```
Now, lets make a simple plot
```{r falseByLat1, eval = FALSE, message = FALSE, warning = FALSE}
## make lat vs time plots of all tags
## now the data looks better and only tag 16038 looks odd
ggplot(JBraw, aes(ts, lat, group = motusTagID)) + geom_point() + geom_line() + facet_wrap(~motusTagID)
```
Tag 16038 looks strange, so we can examine that detection period closer, and then remove any hitIDs we disagree with
```{r falseByLat2, eval = FALSE, message = FALSE, warning = FALSE}
## filter JBraw to only show motusTagID 16038, and only before 2015-10-01
ggplot(filter(JBraw, motusTagID == 16038 & ts < as.POSIXct("2015-10-01")), aes(ts, lat, group = motusTagID)) + geom_point() + geom_line() + facet_wrap(~motusTagID)
```
It is highly unlikely/implausible that this bird travelled such a distance in one day, especially returning to the same receiver, but to confirm we can examine the signal strength of the potentially false detections.
```{r falseByLat3, eval = FALSE, message = FALSE, warning = FALSE}
## this time filter by motusTagID and by latitude so we only see the strange detections
ggplot(filter(JBraw, motusTagID == 16038 & lat < 42), aes(ts, sig, colour = as.factor(ant))) + geom_point() + facet_wrap(~motusTagID)
```
It appears that there were only two detections at this receiver, both detections were captured by all 3 antennas, and they were over a minute apart.  Since the burst rate of this tag is 6.09 seconds, we know that these are not consecutive detections.  These detections are false positives.  So lets identify the hitIDs so we can remove them later.
```{r falseByLat4, eval = FALSE, message = FALSE, warning = FALSE}
## using a filter that will provide us with only the spurious detections:
filter(JBraw, motusTagID == 16038 & lat < 42)
```
We can see that the hitIDs we want to remove are 239875440 - 239875445.  For now we will keep them in the data to continue looking for false positives.  We will remove all of them together at the end of this chapter.

## Removing detections based on estimated flight speed {#filterFlightSpeed}

By looking at the rate of movement between sites with consicutive detections, we can quickly view flights that are not physically possible.  Further examination of these detections will be required to determine which detections are true and which are false.
Rate of movement between sites can be determined using the siteTrans function in the motus R package.  For instructions on installing the package, see chapter "Loading Packages".
```{r falseBySpeed1, eval = FALSE, message = FALSE, warning = FALSE}
JBtrans <- siteTrans(JBraw) ## create new data.base consisting of transitions between consecutive sites for each tag
head(JBtrans)
## so we see that tag 16047 has lots of high speeds due to close towers - 16038 has high speeds due to false detections
## same as what we saw with the plots, so lets remove those hitIDs
tmp <- filter(JBraw, !(hitID %in% c(239875440, 239875441, 239875442, 239875443, 239875444, 239875445)))
```
The resulting database JBtrans shows information on the last detection at site x, and the first detection at site y.  So in the above table, we can see the total time, distance, rate of movement, bearing, and rhumbline_bearing of potential flights between sites.  Rate of movement is presented as m/s.
Because rate of movement is based on receiver location at the time of last and first detection at two sites, it is only an estimation and sites closer together will have less accurate results.  For example, lets look at row 58 from JBtrans:
```{r falseBySpeed2, eval = FALSE, message = FALSE, warning = FALSE}
JBtrans[58,]
```
It would appear that the bird is travelling at a rage of 2203.543 m/s (7,932 km/hr)!  Based on rate alone you may think this is due to false detections, however the two sites are only 22km apart, and the time between detections was only 10 seconds.  This high estimated rate of movement is likely due to the tag being detected at the edge of the detection range of both receivers; remember we do not know how far the tag is from the receiver location at time of detection.
It's therefore important to take all information into consideration when looking at high rates of movement.  Let's look at all cases of high rates of movements, we can be conservative and only look at rates > 50 m/s
```{r falseBySpeed3, eval = FALSE, message = FALSE, warning = FALSE}
filter(JBtrans, rate > 50)
```
Almost all of these flights are between stations that are < 30 km apart so high rates of movement are not surprising.  Only one flight had an impossible rate of movement with stations far apart:
```{r falseBySpeed4, eval = FALSE, message = FALSE, warning = FALSE}
filter(JBtrans, rate > 50 & dist > 40000)
```
Not surprisingly, this is the same tag we identified as having false positives when examining latitudinal plots above.  We can confirm the hitID's by making the same plots as above, or similar ones identifying site name:
```{r falseBySpeed5, eval = FALSE, message = FALSE, warning = FALSE}
ggplot(filter(JBraw, motusTagID == 16038), aes(ts, lat, col = as.factor(site))) + geom_point()
```
We can see that the detections at Illini State Park are the spurious detections, so to determine their hitIDs we can filter by site:
```{r falseBySpeed6, eval = FALSE, message = FALSE, warning = FALSE}
filter(JBraw, motusTagID == 16038 & site == "Illini State Park ")
```
Once again we determine that we should remove hitID's 239875440 - 239875445.

## Removing false positives based on hitID's {#filterHitID}

Now that we have a list of hitID's that we have determined to be false positives, we can easily remove them from our database
```{r falseHitIDs, eval = FALSE, message = FALSE, warning = FALSE}
JBfiltered <- filter(JBraw, !(hitID %in% c(239875440, 239875441, 239875442, 239875443, 239875444, 239875445)))
```

## Removing detections based on automated filtering {#filterAuto}

You can also remove spurious detections through some simple automated filters if you do not wish to examine each tag individually.  But note that by applying a general filter to all your detections, you risk removing true detections as well.  Detections can be filtered by freqsd or by runLen.  
**freqsd** refers to the standard deviation of frequency offset among pulses in a burst, in kHz.  Values larger than 0.1  kHz suggest a bogus detection, however this is for detections on SensorGnomes only.  
**runLen** is the number of tag bursts in the current run, a run is defined as a group of consecutive detections of a tag detected on a receiver.
If you decide to run these filters on your data, it is recommended that you identify the detections you would be removing and examine them to ensure you aren't removing an unwanted amount of true detections.
```{r autofilter1, eval = FALSE, message = FALSE, warning = FALSE}
## first convert freqsd to NA for all Lotek receivers
JBraw$freqsd <- ifelse(grepl("Lotek", JBraw$recv), "NA",JBraw$freqsd)
## identify which detections would be removed by creating a new column "filter"
JBraw$filter <- "KEEP"
JBraw$filter[JBraw$runLen <= 2 & JBraw$freqsd >= 0.1] <- "FILTER"
```
Based on these filters, we can summarize how many detections would be removed based on tag, site, or receiver type:
```{r autofilter2, eval = FALSE, message = FALSE, warning = FALSE}
## potential detections to filter by site
table(JBraw$filter, JBraw$site)
```
Sable West Light 2, and Hogback seem to have relatively higher numbers of spurious detections, note that it didn't filter out the false positives at Illini State Park
```{r autofilter3, eval = FALSE, message = FALSE, warning = FALSE}
## potential detections to filter by motusTagID
table(JBraw$filter, JBraw$motusTagID)
```
motusTagID 16038 seems to have a higher number of spurious detections

From here it is a judgement call whether to filter based on freqsd or runLen, and how strict to make the filters.  You may wish to apply them only to certain sites or certain tag IDs.  There is a balance between removing all questionable detections along with some true detections, vs keeping all detections and potentially having some false positives.  To filter based on the above criteria:
```{r autofilter4, eval = FALSE, message = FALSE, warning = FALSE}
JBraw <- filter(JBraw, filter == "KEEP")
```

Ultimately, how strictly you filter your detection data is up to each individual, but it is well worth your time to work through some or all of these methods to be confident in the accuracy of your detection data.

<!--chapter:end:06-DataCleaning.Rmd-->

# Exploring data with the Motus R package {#exploreData}

There are a number of functions within the Motus package that will allow you to quickly explore your data.  This section provides examples of how you can use these functions through summaries and visualizations.

## Summarizing your data {#dataSummaries}

## Plotting your data {#dataPlotting}

<!--chapter:end:07-ExploringData.Rmd-->

# Appendix A - Database Structure {#appendixA}

The following tables and associated fields are included in each .motus SQLite file:

1. projs

```{r appAfig1, echo=FALSE}
knitr::include_graphics("images/projs.jpg")
```

2. hits

```{r appAfig2, echo=FALSE}
knitr::include_graphics("images/hits.jpg")
```

3. runs

```{r appAfig3, echo=FALSE}
knitr::include_graphics("images/runs.jpg")
```

4. batches

```{r appAfig4, echo=FALSE}
knitr::include_graphics("images/batches.jpg")
```

5. batchRuns

```{r appAfig5, echo=FALSE}
knitr::include_graphics("images/batchRuns.jpg")
```

6. projBatch

```{r appAfig6, echo=FALSE}
knitr::include_graphics("images/projBatch.jpg")
```

7. gps

```{r appAfig7, echo=FALSE}
knitr::include_graphics("images/gps.jpg")
```

8. meta

```{r appAfig8, echo=FALSE}
knitr::include_graphics("images/meta.jpg")
```

9. meta

```{r appAfig9, echo=FALSE}
knitr::include_graphics("images/meta.jpg")
```

10. recvs

```{r appAfig10, echo=FALSE}
knitr::include_graphics("images/recvs.jpg")
```

11. recvDeps

```{r appAfig11, echo=FALSE}
knitr::include_graphics("images/recvDeps.jpg")
```

12. antDeps

```{r appAfig12, echo=FALSE}
knitr::include_graphics("images/antDeps.jpg")
```

13. tags

```{r appAfig13, echo=FALSE}
knitr::include_graphics("images/tags.jpg")
```

14. tagDeps

```{r appAfig14, echo=FALSE}
knitr::include_graphics("images/tagDeps.jpg")
```

15. tagAmbig

```{r appAfig15, echo=FALSE}
knitr::include_graphics("images/tagAmbig.jpg")
```

16. projAmbig

```{r appAfig16, echo=FALSE}
knitr::include_graphics("images/projAmbig.jpg")
```

17. species

```{r appAfig17, echo=FALSE}
knitr::include_graphics("images/species.jpg")
```

<!--chapter:end:08-AppendixA.Rmd-->

